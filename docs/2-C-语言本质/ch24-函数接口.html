<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>函数接口 - Linux C 编程一站式学习</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">说明</a></li><li class="chapter-item expanded affix "><a href="../历史.html">历史</a></li><li class="chapter-item expanded affix "><a href="../前言.html">前言</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/TOC.html"><strong aria-hidden="true">1.</strong> C语言入门</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../1-C-语言入门/ch01-程序的基本概念.html"><strong aria-hidden="true">1.1.</strong> 程序的基本概念</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch02-常量、变量和表达式.html"><strong aria-hidden="true">1.2.</strong> 常量、变量和表达式</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch03-简单函数.html"><strong aria-hidden="true">1.3.</strong> 简单函数</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch04-分支语句.html"><strong aria-hidden="true">1.4.</strong> 分支语句</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch05-深入理解函数.html"><strong aria-hidden="true">1.5.</strong> 深入理解函数</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch06-循环语句.html"><strong aria-hidden="true">1.6.</strong> 循环语句</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch07-结构体.html"><strong aria-hidden="true">1.7.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch08-数组.html"><strong aria-hidden="true">1.8.</strong> 数组</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch09-编码风格.html"><strong aria-hidden="true">1.9.</strong> 编码风格</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch10-gdb.html"><strong aria-hidden="true">1.10.</strong> gdb</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch11-排序与查找.html"><strong aria-hidden="true">1.11.</strong> 排序与查找</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch12-栈与队列.html"><strong aria-hidden="true">1.12.</strong> 栈与队列</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch13-本阶段总结.html"><strong aria-hidden="true">1.13.</strong> 本阶段总结</a></li></ol></li><li class="chapter-item expanded "><a href="../2-C-语言本质/TOC.html"><strong aria-hidden="true">2.</strong> C-语言本质</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../2-C-语言本质/ch14-计算机中数的表示.html"><strong aria-hidden="true">2.1.</strong> 计算机中数的表示</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch15-数据类型详解.html"><strong aria-hidden="true">2.2.</strong> 数据类型详解</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch16-运算符详解.html"><strong aria-hidden="true">2.3.</strong> 运算符详解</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch17-计算机体系结构基础.html"><strong aria-hidden="true">2.4.</strong> 计算机体系结构基础</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch18-x86-汇编程序基础.html"><strong aria-hidden="true">2.5.</strong> x86-汇编程序基础</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch19-汇编与-C-之间的关系.html"><strong aria-hidden="true">2.6.</strong> 汇编与-C-之间的关系</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch20-链接详解.html"><strong aria-hidden="true">2.7.</strong> 链接详解</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch21-预处理.html"><strong aria-hidden="true">2.8.</strong> 预处理</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch22-Makefile-基础.html"><strong aria-hidden="true">2.9.</strong> Makefile-基础</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch23-指针.html"><strong aria-hidden="true">2.10.</strong> 指针</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch24-函数接口.html" class="active"><strong aria-hidden="true">2.11.</strong> 函数接口</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch25-C-标准库.html"><strong aria-hidden="true">2.12.</strong> C-标准库</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch26-链表、二叉树和哈希表.html"><strong aria-hidden="true">2.13.</strong> 链表、二叉树和哈希表</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch27-本阶段总结.html"><strong aria-hidden="true">2.14.</strong> 本阶段总结</a></li></ol></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/TOC.html"><strong aria-hidden="true">3.</strong> Linux-系统编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch28-文件与-IO.html"><strong aria-hidden="true">3.1.</strong> 文件与-IO</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch29-文件系统.html"><strong aria-hidden="true">3.2.</strong> 文件系统</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch30-进程.html"><strong aria-hidden="true">3.3.</strong> 进程</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch31-Shell-脚本.html"><strong aria-hidden="true">3.4.</strong> Shell-脚本</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch32-正则表达式.html"><strong aria-hidden="true">3.5.</strong> 正则表达式</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch33-信号.html"><strong aria-hidden="true">3.6.</strong> 信号</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch34-终端、作业控制与守护进程.html"><strong aria-hidden="true">3.7.</strong> 终端、作业控制与守护进程</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch35-线程.html"><strong aria-hidden="true">3.8.</strong> 线程</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch36-TCP-IP-协议基础.html"><strong aria-hidden="true">3.9.</strong> TCP-IP-协议基础</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch37-socket-编程.html"><strong aria-hidden="true">3.10.</strong> 编程</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linux C 编程一站式学习</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第-24-章-函数接口"><a class="header" href="#第-24-章-函数接口">第 24 章 函数接口</a></h1>
<p>我们在<a href="1-C-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/ch11-%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE#6-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE">第 11 章「排序与查找」第 6 节「折半查找」</a>讲过，函数的调用者和函数的实现者之间订立了一个契约，在调用函数之前，调用者要为实现者提供某些条件，在函数返回时，实现者要对调用者尽到某些义务。如何描述这个契约呢？首先靠函数接口来描述，即函数名，参数，返回值，只要函数和参数的名字起得合理，参数和返回值的类型定得准确，至于这个函数怎么用，调用者单看函数接口就能猜出八九分了。函数接口并不能表达函数的全部语义，这时文档就起了重要的补充作用，函数的文档该写什么，怎么写，Man Page 为我们做了很好的榜样。</p>
<p>函数接口一旦和指针结合起来就变得异常灵活，有五花八门的用法，但是万变不离其宗，只要像<a href="2-C-%E8%AF%AD%E8%A8%80%E6%9C%AC%E8%B4%A8/ch23-%E6%8C%87%E9%92%88#c23-1">第 23 章「指针」图 23.1「指针的基本概念」</a>那样画图分析，指针的任何用法都能分析清楚，所以，如果上一章你真正学明白了，本章不用学也能自己领悟出来，之所以写这一章是为了照顾悟性不高的读者。本章把函数接口总结成几类常见的模式，对于每种模式，一方面讲函数接口怎么写，另一方面讲函数的文档怎么写。</p>
<h2 id="1-本章的预备知识"><a class="header" href="#1-本章的预备知识">1. 本章的预备知识</a></h2>
<p>这一节介绍本章的范例代码要用的几个 C 标准库函数。我们先体会一下这几个函数的接口是怎么设计的，Man Page 是怎么写的。其它常用的 C 标准库函数将在下一章介绍。</p>
<h3 id="11-strcpy-与-strncpy"><a class="header" href="#11-strcpy-与-strncpy">1.1. strcpy 与 strncpy</a></h3>
<p>从现在开始我们要用到很多库函数，在学习每个库函数时一定要看 Man Page。Man Page 随时都在我们手边，想查什么只要敲一个命令就行，然而很多初学者就是不喜欢看 Man Page，宁可满世界去查书、查资料，也不愿意看Man Page。据我分析原因有三：</p>
<ol>
<li>英文不好。那还是先学好了英文再学编程吧，否则即使你把这本书都学透了也一样无法胜任开发工作，因为你没有进一步学习的能力。</li>
<li>Man Page 的语言不够友好。Man Page 不像本书这样由浅入深地讲解，而是平铺直叙，不过看习惯了就好了，每个 Man Page 都不长，多看几遍自然可以抓住重点，理清头绪。本节分析一个例子，帮助读者把握 Man Page 的语言特点。</li>
<li>Man Page 通常没有例子。描述一个函数怎么用，一靠接口，二靠文档，而不是靠例子。函数的用法无非是本章所总结的几种模式，只要把本章学透了，你就不需要每个函数都得有个例子教你怎么用了。</li>
</ol>
<p>总之，Man Page 是一定要看的，一开始看不懂硬着头皮也要看，为了鼓励读者看 Man Page，本书不会像 <em>K&amp;R</em> 那样把库函数总结成一个附录附在书后面。现在我们来分析 <code>strcpy(3)</code>。</p>
<p id="c24-1">图 24.1. strcpy(3)</p>
<p><img src="../images/interface.synopsis.png" alt="strcpy(3)" /></p>
<p>这个 Man Page 描述了两个函数，<code>strcpy</code> 和 <code>strncpy</code>，敲命令 <code>man strcpy</code> 或者 <code>man strncpy</code> 都可以看到这个 Man Page。这两个函数的作用是把一个字符串拷贝给另一个字符串。<strong>SYNOPSIS</strong> 部分给出了这两个函数的原型，以及要用这些函数需要包含哪些头文件。参数 <code>dest</code>、<code>src</code> 和 <code>n</code> 都加了下划线，有时候并不想从头到尾阅读整个 Man Page，而是想查一下某个参数的含义，通过下划线和参数名就能很快找到你关心的部分。</p>
<p><code>dest</code> 表示 Destination，<code>src</code> 表示 Source，看名字就能猜到是把 <code>src</code> 所指向的字符串拷贝到 <code>dest</code> 所指向的内存空间。这一点从两个参数的类型也能看出来，<code>dest</code> 是 <code>char *</code> 型的，而 <code>src</code> 是 <code>const char *</code> 型的，说明 <code>src</code> 所指向的内存空间在函数中只能读不能改写，而 <code>dest</code> 所指向的内存空间在函数中是要改写的，显然改写的目的是当函数返回后调用者可以读取改写的结果。因此可以猜到 <code>strcpy</code> 函数是这样用的：</p>
<pre><code class="language-c">char buf[10];
strcpy(buf, &quot;hello&quot;);
printf(buf);
</code></pre>
<p>至于 <code>strncpy</code> 的参数 <code>n</code> 是干什么用的，单从函数接口猜不出来，就需要看下面的文档。</p>
<p id="c24-2">图 24.2. strcpy(3)</p>
<p><img src="../images/interface.description.png" alt="strcpy(3)" /></p>
<p>在文档中强调了 <code>strcpy</code> 在拷贝字符串时会把结尾的 <code>'\0'</code> 也拷到 <code>dest</code> 中，因此保证了 <code>dest</code> 中是以 <code>'\0'</code> 结尾的字符串。但另外一个要注意的问题是，<code>strcpy</code> 只知道 <code>src</code> 字符串的首地址，不知道长度，它会一直拷贝到 <code>'\0'</code> 为止，所以 <code>dest</code> 所指向的内存空间要足够大，否则有可能写越界，例如：</p>
<pre><code class="language-c">char buf[10];
strcpy(buf, &quot;hello world&quot;);
</code></pre>
<p>如果没有保证 <code>src</code> 所指向的内存空间以 <code>'\0'</code> 结尾，也有可能读越界，例如：</p>
<pre><code class="language-c">char buf[10] = &quot;abcdefghij&quot;, str[4] = &quot;hell&quot;;
strcpy(buf, str);
</code></pre>
<p>因为 <code>strcpy</code> 函数的实现者通过函数接口无法得知 <code>src</code> 字符串的长度和 <code>dest</code> 内存空间的大小，所以“确保不会写越界”应该是调用者的责任，调用者提供的 <code>dest</code> 参数应该指向足够大的内存空间，“确保不会读越界”也是调用者的责任，调用者提供的 <code>src</code> 参数指向的内存应该确保以 <code>'\0'</code> 结尾。</p>
<p>此外，文档中还强调了 <code>src</code> 和 <code>dest</code> 所指向的内存空间不能有重叠。凡是有指针参数的 C 标准库函数基本上都有这条要求，每个指针参数所指向的内存空间互不重叠，例如这样调用是不允许的：</p>
<pre><code class="language-c">char buf[10] = &quot;hello&quot;;
strcpy(buf, buf+1);
</code></pre>
<p><code>strncpy</code> 的参数 <code>n</code> 指定最多从 <code>src</code> 中拷贝 <code>n</code> 个字节到 <code>dest</code> 中，换句话说，如果拷贝到 <code>'\0'</code> 就结束，如果拷贝到 <code>n</code> 个字节还没有碰到 <code>'\0'</code>，那么也结束，调用者负责提供适当的 <code>n</code> 值，以确保读写不会越界，比如让 <code>n</code> 的值等于 <code>dest</code> 所指向的内存空间的大小：</p>
<pre><code class="language-c">char buf[10];
strncpy(buf, &quot;hello world&quot;, sizeof(buf));
</code></pre>
<p>然而这意味着什么呢？文档中特别用了 <strong>Warning</strong> 指出，这意味着 <code>dest</code> 有可能不是以 <code>'\0'</code> 结尾的。例如上面的调用，虽然把 <code>&quot;hello world&quot;</code> 截断到 10 个字符拷贝至 <code>buf</code> 中，但 <code>buf</code> 不是以 <code>'\0'</code> 结尾的，如果再 <code>printf(buf)</code> 就会读越界。如果你需要确保 <code>dest</code> 以 <code>'\0'</code> 结束，可以这么调用：</p>
<pre><code class="language-c">char buf[10];
strncpy(buf, &quot;hello world&quot;, sizeof(buf));
buf[sizeof(buf)-1] = '\0';
</code></pre>
<p><code>strncpy</code> 还有一个特性，如果 <code>src</code> 字符串全部拷完了不足 <code>n</code> 个字节，那么还差多少个字节就补多少个 <code>'\0'</code>，但是正如上面所述，这并不保证 <code>dest</code> 一定以 <code>'\0'</code> 结束，当 <code>src</code> 字符串的长度大于 <code>n</code> 时，不但不补多余的 <code>'\0'</code>，连字符串的结尾 <code>'\0'</code> 也不拷贝。<code>strcpy(3)</code> 的文档已经相当友好了，为了帮助理解，还给出一个 <code>strncpy</code> 的简单实现。</p>
<p id="c24-3">图 24.3. strcpy(3)</p>
<p><img src="../images/interface.return.png" alt="strcpy(3)" /></p>
<p>函数的 Man Page 都有一部分专门讲返回值的。这两个函数的返回值都是 <code>dest</code> 指针。可是为什么要返回 <code>dest</code> 指针呢？<code>dest</code> 指针本来就是调用者传过去的，再返回一遍 <code>dest</code> 指针并没有提供任何有用的信息。之所以这么规定是为了把函数调用当作一个指针类型的表达式使用，比如 <code>printf(&quot;%s\n&quot;, strcpy(buf, &quot;hello&quot;))</code>，一举两得，如果 <code>strcpy</code> 的返回值是 <code>void</code> 就没有这么方便了。</p>
<p><strong>CONFORMING TO</strong> 部分描述了这个函数是遵照哪些标准实现的。<code>strcpy</code> 和 <code>strncpy</code> 是 C 标准库函数，当然遵照 C99 标准。以后我们还会看到 <code>libc</code> 中有些函数属于 POSIX 标准但并不属于 C 标准，例如 <code>write(2)</code>。</p>
<p><strong>NOTES</strong> 部分给出一些提示信息。这里指出如何确保 <code>strncpy</code> 的 <code>dest</code> 以 <code>'\0'</code> 结尾，和我们上面给出的代码类似，但由于 <code>n</code> 是个变量，在执行 <code>buf[n - 1]= '\0';</code> 之前先检查一下 <code>n</code> 是否大于 0，如果 <code>n</code> 不大于 0，<code>buf[n - 1]</code> 就访问越界了，所以要避免。</p>
<p id="c24-4">图 24.4. strcpy(3)</p>
<p><img src="../images/interface.bugs.png" alt="strcpy(3)" /></p>
<p><strong>BUGS</strong> 部分说明了使用这些函数可能引起的 Bug，这部分一定要仔细看。用 <code>strcpy</code> 比用 <code>strncpy</code> 更加不安全，如果在调用 <code>strcpy</code> 之前不仔细检查 <code>src</code> 字符串的长度就有可能写越界，这是一个很常见的错误，例如：</p>
<pre><code class="language-c">void foo(char *str)
{
	char buf[10];
	strcpy(buf, str);
	...
}
</code></pre>
<p><code>str</code> 所指向的字符串有可能超过 10 个字符而导致写越界，在<a href="1-C-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/ch10-gdb#_4-%E6%AE%B5%E9%94%99%E8%AF%AF">第 10 章「gdb」第 4 节「段错误」</a>我们看到过，这种写越界可能当时不出错，而在函数返回时出现段错误，原因是写越界覆盖了保存在栈帧上的返回地址，函数返回时跳转到非法地址，因而出错。像 <code>buf</code> 这种由调用者分配并传给函数读或写的一段内存通常称为缓冲区（Buffer），缓冲区写越界的错误称为缓冲区溢出（Buffer Overflow）。如果只是出现段错误那还不算严重，更严重的是缓冲区溢出 Bug 经常被恶意用户利用，使函数返回时跳转到一个事先设好的地址，执行事先设好的指令，如果设计得巧妙甚至可以启动一个 Shell，然后随心所欲执行任何命令，可想而知，如果一个用 <code>root</code> 权限执行的程序存在这样的 Bug，被攻陷了，后果将很严重。至于怎样巧妙设计和攻陷一个有缓冲区溢出 Bug 的程序，有兴趣的读者可以参考 <em>SmashStack</em>。</p>
<h4 id="习题"><a class="header" href="#习题">习题</a></h4>
<ol>
<li>
<p>自己实现一个 <code>strcpy</code> 函数，尽可能简洁，按照本书的编码风格你能用三行代码写出函数体吗？</p>
</li>
<li>
<p>编一个函数，输入一个字符串，要求做一个新字符串，把其中所有的一个或多个连续的空白字符都压缩为一个空格。这里所说的空白包括空格、'\t'、'\n'、'\r'。例如原来的字符串是：</p>
<pre><code class="language-c">This Content hoho       is ok
        ok?

        file system
uttered words   ok ok      ?
end.
</code></pre>
<p>压缩了空白之后就是：</p>
<pre><code>This Content hoho is ok ok? file system uttered words ok ok ? end.
</code></pre>
<p>实现该功能的函数接口要求符合下述规范：</p>
<pre><code>char *shrink_space(char *dest, const char *src, size_t n);
</code></pre>
<p>各项参数和返回值的含义和 <code>strncpy</code> 类似。完成之后，为自己实现的函数写一个 Man Page。</p>
</li>
</ol>
<h3 id="12-malloc-与-free"><a class="header" href="#12-malloc-与-free">1.2. malloc 与 free</a></h3>
<p>程序中需要动态分配一块内存时怎么办呢？可以像上一节那样定义一个缓冲区数组。这种方法不够灵活，C89 要求定义的数组是固定长度的，而程序往往在运行时才知道要动态分配多大的内存，例如：</p>
<pre><code class="language-c">void foo(char *str, int n)
{
	char buf[?];
	strncpy(buf, str, n);
	...
}
</code></pre>
<p><code>n</code> 是由参数传进来的，事先不知道是多少，那么 <code>buf</code> 该定义多大呢？在<a href="1-C-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/ch08-%E6%95%B0%E7%BB%84#_1-%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">第 8 章「数组」第 1 节「数组的基本概念」</a>讲过 C99 引入 VLA 特性，可以定义 <code>char buf[n+1] = {};</code>，这样可确保 <code>buf</code> 是以 <code>'\0'</code> 结尾的。但即使用 VLA 仍然不够灵活，VLA 是在栈上动态分配的，函数返回时就要释放，如果我们希望动态分配一块全局的内存空间，在各函数中都可以访问呢？由于全局数组无法定义成 VLA，所以仍然不能满足要求。</p>
<p>其实在<a href="2-C-%E8%AF%AD%E8%A8%80%E6%9C%AC%E8%B4%A8/ch20-%E9%93%BE%E6%8E%A5%E8%AF%A6%E8%A7%A3#_5-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">第 20 章「链接详解」第 5 节「虚拟内存管理」</a>提过，进程有一个堆空间，C 标准库函数 <code>malloc</code> 可以在堆空间动态分配内存，它的底层通过 <code>brk</code> 系统调用向操作系统申请内存。动态分配的内存用完之后可以用 <code>free</code> 释放，更准确地说是归还给 <code>malloc</code>，这样下次调用 <code>malloc</code> 时这块内存可以再次被分配。本节学习这两个函数的用法和工作原理。</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

void *malloc(size_t size);
返回值：成功返回所分配内存空间的首地址，出错返回 NULL

void free(void *ptr);
</code></pre>
<p><code>malloc</code> 的参数 <code>size</code> 表示要分配的字节数，如果分配失败（可能是由于系统内存耗尽）则返回 <code>NULL</code>。由于 <code>malloc</code> 函数不知道用户拿到这块内存要存放什么类型的数据，所以返回通用指针 <code>void *</code>，用户程序可以转换成其它类型的指针再访问这块内存。<code>malloc</code> 函数保证它返回的指针所指向的地址满足系统的对齐要求，例如在 32 位平台上返回的指针一定对齐到 4 字节边界，以保证用户程序把它转换成任何类型的指针都能用。</p>
<p>动态分配的内存用完之后可以用 <code>free</code> 释放掉，传给 <code>free</code> 的参数正是先前 <code>malloc</code> 返回的内存块首地址。举例如下：</p>
<p id="e24-1">例 24.1. malloc 和 free</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct {
	int number;
	char *msg;
} unit_t;

int main(void)
{
	unit_t *p = malloc(sizeof(unit_t));

	if (p == NULL) {
		printf(&quot;out of memory\n&quot;);
		exit(1);
	}
	p-&gt;number = 3;
	p-&gt;msg = malloc(20);
	strcpy(p-&gt;msg, &quot;Hello world!&quot;);
	printf(&quot;number: %d\nmsg: %s\n&quot;, p-&gt;number, p-&gt;msg);
	free(p-&gt;msg);
	free(p);
	p = NULL;

	return 0;
}
</code></pre>
<p>关于这个程序要注意以下几点：</p>
<ul>
<li><code>unit_t *p = malloc(sizeof(unit_t));</code> 这一句，等号右边是 <code>void *</code> 类型，等号左边是 <code>unit_t *</code> 类型，编译器会做隐式类型转换，我们讲过 <code>void *</code> 类型和任何指针类型之间可以相互隐式转换。</li>
<li>虽然内存耗尽是很不常见的错误，但写程序要规范，<code>malloc</code> 之后应该判断是否成功。以后要学习的大部分系统函数都有成功的返回值和失败的返回值，每次调用系统函数都应该判断是否成功。</li>
<li><code>free(p);</code> 之后，<code>p</code> 所指的内存空间是归还了，但是 <code>p</code> 的值并没有变，因为从 <code>free</code> 的函数接口来看根本就没法改变 <code>p</code> 的值，<code>p</code> 现在指向的内存空间已经不属于用户，换句话说，<code>p</code> 成了野指针，为避免出现野指针，我们应该在 <code>free(p);</code> 之后手动置 <code>p = NULL;</code>。</li>
<li>应该先 <code>free(p-&gt;msg)</code>，再 <code>free(p)</code>。如果先 <code>free(p)</code>，<code>p</code> 成了野指针，就不能再通过 <code>p-&gt;msg</code> 访问内存了。</li>
</ul>
<p>上面的例子只有一个简单的顺序控制流程，分配内存，赋值，打印，释放内存，退出程序。这种情况下即使不用 <code>free</code> 释放内存也可以，因为程序退出时整个进程地址空间都会释放，包括堆空间，该进程占用的所有内存都会归还给操作系统。但如果一个程序长年累月运行（例如网络服务器程序），并且在循环或递归中调用 <code>malloc</code> 分配内存，则必须有 <code>free</code> 与之配对，分配一次就要释放一次，否则每次循环都分配内存，分配完了又不释放，就会慢慢耗尽系统内存，这种错误称为内存泄漏（Memory Leak）。另外，<code>malloc</code> 返回的指针一定要保存好，只有把它传给 <code>free</code> 才能释放这块内存，如果这个指针丢失了，就没有办法 <code>free</code> 这块内存了，也会造成内存泄漏。例如：</p>
<pre><code class="language-c">void foo(void)
{
	char *p = malloc(10);
	...
}
</code></pre>
<p><code>foo</code> 函数返回时要释放局部变量 <code>p</code> 的内存空间，它所指向的内存地址就丢失了，这 10 个字节也就没法释放了。内存泄漏的 Bug 很难找到，因为它不会像访问越界一样导致程序运行错误，少量内存泄漏并不影响程序的正确运行，大量的内存泄漏会使系统内存紧缺，导致频繁换页，不仅影响当前进程，而且把整个系统都拖得很慢。</p>
<p>关于 <code>malloc</code> 和 <code>free</code> 还有一些特殊情况。<code>malloc(0)</code> 这种调用也是合法的，也会返回一个非 <code>NULL</code> 的指针，这个指针也可以传给 <code>free</code> 释放，但是不能通过这个指针访问内存。<code>free(NULL)</code> 也是合法的，不做任何事情，但是 <code>free</code> 一个野指针是不合法的，例如先调用 <code>malloc</code> 返回一个指针 <code>p</code>，然后连着调用两次 <code>free(p);</code>，则后一次调用会产生运行时错误。</p>
<p><em>K&amp;R</em> 的 8.7 节给出了 <code>malloc</code> 和 <code>free</code> 的简单实现，基于环形链表。目前读者还没有学习链表，看那段代码会有点困难，我再做一些简化，图示如下，目的是让读者理解 <code>malloc</code> 和 <code>free</code> 的工作原理。<code>libc</code> 的实现比这要复杂得多，但基本工作原理也是如此。读者只要理解了基本工作原理，就很容易分析在使用 <code>malloc</code> 和 <code>free</code> 时遇到的各种 Bug 了。</p>
<p id="c24-5">图 24.5. 简单的malloc和free实现</p>
<p><img src="../images/interface.malloc.png" alt="简单的 malloc 和 free 实现" /></p>
<p>图中白色背景的框表示 <code>malloc</code> 管理的空闲内存块，深色背景的框不归 <code>malloc</code> 管，可能是已经分配给用户的内存块，也可能不属于当前进程，Break 之上的地址不属于当前进程，需要通过 <code>brk</code> 系统调用向内核申请。每个内存块开头都有一个头节点，里面有一个指针字段和一个长度字段，指针字段把所有空闲块的头节点串在一起，组成一个环形链表，长度字段记录着头节点和后面的内存块加起来一共有多长，以 8 字节为单位（也就是以头节点的长度为单位）。</p>
<ol>
<li>一开始堆空间由一个空闲块组成，长度为 7×8=56 字节，除头节点之外的长度为 48 字节。</li>
<li>调用 <code>malloc</code> 分配 8 个字节，要在这个空闲块的末尾截出 16 个字节，其中新的头节点占了 8 个字节，另外 8 个字节返回给用户使用，注意返回的指针 <code>p1</code> 指向头节点后面的内存块。</li>
<li>又调用 <code>malloc</code> 分配 16 个字节，又在空闲块的末尾截出 24 个字节，步骤和上一步类似。</li>
<li>调用 <code>free</code> 释放 <code>p1</code> 所指向的内存块，内存块（包括头节点在内）归还给了 <code>malloc</code>，现在 <code>malloc</code> 管理着两块不连续的内存，用环形链表串起来。注意这时 <code>p1</code> 成了野指针，指向不属于用户的内存，<code>p1</code> 所指向的内存地址在 Break 之下，是属于当前进程的，所以访问 <code>p1</code> 时不会出现段错误，但在访问 <code>p1</code> 时这段内存可能已经被 <code>malloc</code> 再次分配出去了，可能会读到意外改写数据。另外注意，此时如果通过 <code>p2</code> 向右写越界，有可能覆盖右边的头节点，从而破坏 <code>malloc</code> 管理的环形链表，<code>malloc</code> 就无法从一个空闲块的指针字段找到下一个空闲块了，找到哪去都不一定，全乱套了。</li>
<li>调用 <code>malloc</code> 分配 16 个字节，现在虽然有两个空闲块，各有 8 个字节可分配，但是这两块不连续，<code>malloc</code> 只好通过 <code>brk</code> 系统调用抬高 Break，获得新的内存空间。在 <em>K&amp;R</em> 的实现中，每次调用 <code>sbrk</code> 函数时申请 1024×8=8192 个字节，在 Linux 系统上 <code>sbrk</code> 函数也是通过 <code>brk</code> 实现的，这里为了画图方便，我们假设每次调用 <code>sbrk</code> 申请 32 个字节，建立一个新的空闲块。</li>
<li>新申请的空闲块和前一个空闲块连续，因此可以合并成一个。在能合并时要尽量合并，以免空闲块越割越小，无法满足大的分配请求。</li>
<li>在合并后的这个空闲块末尾截出 24 个字节，新的头节点占 8 个字节，另外 16 个字节返回给用户。</li>
<li>调用 <code>free(p3)</code> 释放这个内存块，由于它和前一个空闲块连续，又重新合并成一个空闲块。注意，Break 只能抬高而不能降低，从内核申请到的内存以后都归 <code>malloc</code> 管了，即使调用 <code>free</code> 也不会还给内核。</li>
</ol>
<h4 id="习题-1"><a class="header" href="#习题-1">习题</a></h4>
<ol>
<li>小练习：编写一个小程序让它耗尽系统内存。观察一下，分配了多少内存后才会出现分配失败？内存耗尽之后会怎么样？会不会死机？</li>
</ol>
<h2 id="2-传入参数与传出参数"><a class="header" href="#2-传入参数与传出参数">2. 传入参数与传出参数</a></h2>
<p>如果函数接口有指针参数，既可以把指针所指向的数据传给函数使用（称为传入参数），也可以由函数填充指针所指的内存空间，传回给调用者使用（称为传出参数），例如 <code>strcpy</code> 的 <code>src</code> 参数是传入参数，<code>dest</code> 参数是传出参数。有些函数的指针参数同时担当了这两种角色，如 <code>select(2)</code> 的 <code>fd_set *</code> 参数，既是传入参数又是传出参数，这称为 Value-result 参数。</p>
<p id="t24-1">表 24.1. 传入参数示例：`void func(const unit_t \*p);`</p>
<table><thead><tr><th>调用者</th><th>实现者</th></tr></thead><tbody>
<tr><td>分配 <code>p</code> 所指的内存空间在 <code>p</code> 所指的内存空间中保存数据调用函数由于有 <code>const</code> 限定符，调用者可以确信 <code>p</code> 所指的内存空间不会被改变</td><td>规定指针参数的类型 <code>unit_t *</code> 读取 <code>p</code> 所指的内存空间</td></tr>
</tbody></table>
<p>想一想，如果有函数接口 <code>void func(const int p);</code> 这里的 <code>const</code> 有意义吗？</p>
<p id="t24-2">表 24.2. 传出参数示例：`void func(unit_t \*p);`</p>
<table><thead><tr><th>调用者</th><th>实现者</th></tr></thead><tbody>
<tr><td>分配 <code>p</code> 所指的内存空间调用函数读取 <code>p</code> 所指的内存空间</td><td>规定指针参数的类型 <code>unit_t *</code> 在 <code>p</code> 所指的内存空间中保存数据</td></tr>
</tbody></table>
<p id="t24-3">表 24.3. Value-result 参数示例：void func(unit_t \*p);</p>
<table><thead><tr><th>调用者</th><th>实现者</th></tr></thead><tbody>
<tr><td>分配 p 所指的内存空间在 <code>p</code> 所指的内存空间保存数据调用函数读取 <code>p</code> 所指的内存空间</td><td>规定指针参数的类型 <code>unit_t *</code> 读取 <code>p</code> 所指的内存空间改写 <code>p</code> 所指的内存空间</td></tr>
</tbody></table>
<p>由于传出参数和 Value-result 参数的函数接口完全相同，应该在文档中说明是哪种参数。</p>
<p>以下是一个传出参数的完整例子：</p>
<p id="e24-2">例 24.2. 传出参数</p>
<pre><code class="language-c">/* populator.h */
#ifndef POPULATOR_H
#define POPULATOR_H

typedef struct {
     int number;
     char msg[20];
} unit_t;

extern void set_unit(unit_t *);

#endif
/* populator.c */
#include &lt;string.h&gt;
#include &quot;populator.h&quot;

void set_unit(unit_t *p)
{
     if (p == NULL)
          return; /* ignore NULL parameter */
     p-&gt;number = 3;
     strcpy(p-&gt;msg, &quot;Hello World!&quot;);
}
/* main.c */
#include &lt;stdio.h&gt;
#include &quot;populator.h&quot;

int main(void)
{
     unit_t u;

     set_unit(&amp;u);
     printf(&quot;number: %d\nmsg: %s\n&quot;, u.number, u.msg);
     return 0;
}
</code></pre>
<p>很多系统函数对于指针参数是 <code>NULL</code> 的情况有特殊规定：如果传入参数是 <code>NULL</code> 表示取缺省值，例如 <code>pthread_create(3)</code> 的 <code>pthread_attr_t *</code> 参数，也可能表示不做特别处理，例如 <code>free</code> 的参数；如果传出参数是 <code>NULL</code> 表示调用者不需要传出值，例如 <code>time(2)</code> 的参数。这些特殊规定应该在文档中写清楚。</p>
<h2 id="3-两层指针的参数"><a class="header" href="#3-两层指针的参数">3. 两层指针的参数</a></h2>
<p>两层指针也是指针，同样可以表示传入参数、传出参数或者 Value-result 参数，只不过该参数所指的内存空间应该解释成一个指针变量。用两层指针做传出参数的系统函数也很常见，比如 <code>pthread_join(3)</code> 的 <code>void **</code> 参数。下面看一个简单的例子。</p>
<p id="e24-3">例 24.3. 两层指针做传出参数</p>
<pre><code class="language-c">/* redirect_ptr.h */
#ifndef REDIRECT_PTR_H
#define REDIRECT_PTR_H

extern void get_a_day(const char **);

#endif
</code></pre>
<p>想一想，这里的参数指针是 <code>const char **</code>，有 <code>const</code> 限定符，却不是传入参数而是传出参数，为什么？如果是传入参数应该怎么表示？</p>
<pre><code class="language-c">/* redirect_ptr.c */
#include &quot;redirect_ptr.h&quot;

static const char *msg[] = {&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;,
			&quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;};
void get_a_day(const char **pp)
{
     static int i = 0;
     *pp = msg[i%7];
     i++;
}
/* main.c */
#include &lt;stdio.h&gt;
#include &quot;redirect_ptr.h&quot;

int main(void)
{
     const char *firstday = NULL;
     const char *secondday = NULL;
     get_a_day(&amp;firstday);
     get_a_day(&amp;secondday);
     printf(&quot;%s\t%s\n&quot;, firstday, secondday);
     return 0;
}
</code></pre>
<p>两层指针作为传出参数还有一种特别的用法，可以在函数中分配内存，调用者通过传出参数取得指向该内存的指针，比如 <code>getaddrinfo(3)</code> 的 <code>struct addrinfo **</code> 参数。一般来说，实现一个分配内存的函数就要实现一个释放内存的函数，所以 <code>getaddrinfo(3)</code> 有一个对应的 <code>freeaddrinfo(3)</code> 函数。</p>
<p id="t24-4">表 24.4. 通过参数分配内存示例：`void alloc_unit(unit_t \**pp);` `void free_unit(unit_t \*p);`</p>
<table><thead><tr><th>调用者</th><th>实现者</th></tr></thead><tbody>
<tr><td>分配 <code>pp</code> 所指的指针变量的空间调用 <code>alloc_unit</code> 分配内存读取 <code>pp</code> 所指的指针变量，通过后者使用 <code>alloc_unit</code> 分配的内存调用 <code>free_unit</code> 释放内存</td><td>规定指针参数的类型 <code>unit_t **</code> <code>alloc_unit</code> 分配 <code>unit_t</code> 的内存并初始化，为 <code>pp</code> 所指的指针变量赋值 <code>free_unit</code> 释放在 <code>alloc_unit</code> 中分配的内存</td></tr>
</tbody></table>
<p id="e24-4">例 24.4. 通过两层指针参数分配内存</p>
<pre><code class="language-c">/* para_allocator.h */
#ifndef PARA_ALLOCATOR_H
#define PARA_ALLOCATOR_H

typedef struct {
     int number;
     char *msg;
} unit_t;

extern void alloc_unit(unit_t **);
extern void free_unit(unit_t *);

#endif
/* para_allocator.c */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;para_allocator.h&quot;

void alloc_unit(unit_t **pp)
{
     unit_t *p = malloc(sizeof(unit_t));
     if(p == NULL) {
	  printf(&quot;out of memory\n&quot;);
	  exit(1);
     }
     p-&gt;number = 3;
     p-&gt;msg = malloc(20);
     strcpy(p-&gt;msg, &quot;Hello World!&quot;);
     *pp = p;
}

void free_unit(unit_t *p)
{
     free(p-&gt;msg);
     free(p);
}
/* main.c */
#include &lt;stdio.h&gt;
#include &quot;para_allocator.h&quot;

int main(void)
{
     unit_t *p = NULL;

     alloc_unit(&amp;p);
     printf(&quot;number: %d\nmsg: %s\n&quot;, p-&gt;number, p-&gt;msg);
     free_unit(p);
     p = NULL;
     return 0;
}
</code></pre>
<p>思考一下，为什么在 <code>main</code> 函数中不能直接调用 <code>free(p)</code> 释放内存，而要调用 <code>free_unit(p)</code>？为什么一层指针的函数接口 <code>void alloc_unit(unit_t *p);</code> 不能分配内存，而一定要用两层指针的函数接口？</p>
<p>总结一下，两层指针参数如果是传出的，可以有两种情况：第一种情况，传出的指针指向静态内存（比如上面的例子），或者指向已分配的动态内存（比如指向某个链表的节点）；第二种情况是在函数中动态分配内存，然后传出的指针指向这块内存空间，这种情况下调用者应该在使用内存之后调用释放内存的函数，调用者的责任是请求分配和请求释放内存，实现者的责任是完成分配内存和释放内存的操作。由于这两种情况的函数接口相同，应该在文档中说明是哪一种情况。</p>
<h2 id="4-返回值是指针的情况"><a class="header" href="#4-返回值是指针的情况">4. 返回值是指针的情况</a></h2>
<p>返回值显然是传出的而不是传入的，如果返回值传出的是指针，和上一节通过参数传出指针类似，也分为两种情况：第一种是传出指向静态内存或已分配的动态内存的指针，例如 <code>localtime(3)</code> 和 <code>inet_ntoa(3)</code>，第二种是在函数中动态分配内存并传出指向这块内存的指针，例如 <code>malloc(3)</code>，这种情况通常还要实现一个释放内存的函数，所以有和 <code>malloc(3)</code> 对应的 <code>free(3)</code>。由于这两种情况的函数接口相同，应该在文档中说明是哪一种情况。</p>
<p id="t24-5">表 24.5. 返回指向已分配内存的指针示例：`unit_t \*func(void);`</p>
<table><thead><tr><th>调用者</th><th>实现者</th></tr></thead><tbody>
<tr><td>调用函数将返回值保存下来以备后用</td><td>规定返回值指针的类型 <code>unit_t *</code> 返回一个指针</td></tr>
</tbody></table>
<p>以下是一个完整的例子。</p>
<p id="e24-5">例 24.5. 返回指向已分配内存的指针</p>
<pre><code class="language-c">/* ret_ptr.h */
#ifndef RET_PTR_H
#define RET_PTR_H

extern char *get_a_day(int idx);

#endif
/* ret_ptr.c */
#include &lt;string.h&gt;
#include &quot;ret_ptr.h&quot;

static const char *msg[] = {&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;,
			&quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;};

char *get_a_day(int idx)
{
     static char buf[20];
     strcpy(buf, msg[idx]);
     return buf;
}
/* main.c */
#include &lt;stdio.h&gt;
#include &quot;ret_ptr.h&quot;

int main(void)
{
     printf(&quot;%s %s\n&quot;, get_a_day(0), get_a_day(1));
     return 0;
}
</code></pre>
<p>这个程序的运行结果是 <code>Sunday Monday</code> 吗？请读者自己分析一下。</p>
<p id="t24-6">表 24.6. 动态分配内存并返回指针示例：`unit_t \*alloc_unit(void); void free_unit(unit_t \*p);`</p>
<table><thead><tr><th>调用者</th><th>实现者</th></tr></thead><tbody>
<tr><td>调用 <code>alloc_unit</code> 分配内存将返回值保存下来以备后用调用 <code>free_unit</code> 释放内存</td><td>规定返回值指针的类型 <code>unit_t *``alloc_unit</code> 分配内存并返回指向该内存的指针 <code>free_unit</code> 释放由 <code>alloc_unit</code> 分配的内存</td></tr>
</tbody></table>
<p>以下是一个完整的例子。</p>
<p id="e24-6">例 24.6. 动态分配内存并返回指针</p>
<pre><code class="language-c">/* ret_allocator.h */
#ifndef RET_ALLOCATOR_H
#define RET_ALLOCATOR_H

typedef struct {
     int number;
     char *msg;
} unit_t;

extern unit_t *alloc_unit(void);
extern void free_unit(unit_t *);

#endif
/* ret_allocator.c */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;ret_allocator.h&quot;

unit_t *alloc_unit(void)
{
     unit_t *p = malloc(sizeof(unit_t));
     if(p == NULL) {
	  printf(&quot;out of memory\n&quot;);
	  exit(1);
     }
     p-&gt;number = 3;
     p-&gt;msg = malloc(20);
     strcpy(p-&gt;msg, &quot;Hello world!&quot;);
     return p;
}

void free_unit(unit_t *p)
{
     free(p-&gt;msg);
     free(p);
}
/* main.c */
#include &lt;stdio.h&gt;
#include &quot;ret_allocator.h&quot;

int main(void)
{
     unit_t *p = alloc_unit();

     printf(&quot;number: %d\nmsg: %s\n&quot;, p-&gt;number, p-&gt;msg);
     free_unit(p);
     p = NULL;
     return 0;
}
</code></pre>
<p>思考一下，通过参数分配内存需要两层的指针，而通过返回值分配内存就只需要返回一层的指针，为什么？</p>
<h2 id="5-回调函数"><a class="header" href="#5-回调函数">5. 回调函数</a></h2>
<p>如果参数是一个函数指针，调用者可以传递一个函数的地址给实现者，让实现者去调用它，这称为回调函数（Callback Function）。例如<code>qsort(3)</code>和<code>bsearch(3)</code>。</p>
<p id="t24-7">表 24.7. 回调函数示例：`void func(void (\*f)(void \*), void \*p);`</p>
<table><thead><tr><th>调用者</th><th>实现者</th></tr></thead><tbody>
<tr><td>提供一个回调函数，再提供一个准备传给回调函数的参数。把回调函数传给参数 <code>f</code>，把准备传给回调函数的参数按 <code>void *</code> 类型传给参数 <code>p</code></td><td>在适当的时候根据调用者传来的函数指针 <code>f</code> 调用回调函数，将调用者传来的参数 <code>p</code> 转交给回调函数，即调用 <code>f(p);</code></td></tr>
</tbody></table>
<p>以下是一个简单的例子。实现了一个 <code>repeat_three_times</code> 函数，可以把调用者传来的任何回调函数连续执行三次。</p>
<p id="e24-7">例 24.7. 回调函数</p>
<pre><code class="language-c">/* para_callback.h */
#ifndef PARA_CALLBACK_H
#define PARA_CALLBACK_H

typedef void (*callback_t)(void *);
extern void repeat_three_times(callback_t, void *);

#endif
/* para_callback.c */
#include &quot;para_callback.h&quot;

void repeat_three_times(callback_t f, void *para)
{
     f(para);
     f(para);
     f(para);
}
/* main.c */
#include &lt;stdio.h&gt;
#include &quot;para_callback.h&quot;

void say_hello(void *str)
{
     printf(&quot;Hello %s\n&quot;, (const char *)str);
}

void count_numbers(void *num)
{
     int i;
     for(i=1; i&lt;=(int)num; i++)
	  printf(&quot;%d &quot;, i);
     putchar('\n');
}

int main(void)
{
     repeat_three_times(say_hello, &quot;Guys&quot;);
     repeat_three_times(count_numbers, (void *)4);
     return 0;
}
</code></pre>
<p>回顾一下前面几节的例子，参数类型都是由实现者规定的。而本例中回调函数的参数按什么类型解释由调用者规定，对于实现者来说就是一个 <code>void *</code> 指针，实现者只负责将这个指针转交给回调函数，而不关心它到底指向什么数据类型。调用者知道自己传的参数是 <code>char *</code> 型的，那么在自己提供的回调函数中就应该知道参数要转换成 <code>char *</code> 型来解释。</p>
<p>回调函数的一个典型应用就是实现类似 C++ 的泛型算法（Generics Algorithm）。下面实现的 <code>max</code> 函数可以在任意一组对象中找出最大值，可以是一组 <code>int</code>、一组 <code>char</code> 或者一组结构体，但是实现者并不知道怎样去比较两个对象的大小，调用者需要提供一个做比较操作的回调函数。</p>
<p id="e24-8">例 24.8. 泛型算法</p>
<pre><code class="language-c">/* generics.h */
#ifndef GENERICS_H
#define GENERICS_H

typedef int (*cmp_t)(void *, void *);
extern void *max(void *data[], int num, cmp_t cmp);

#endif
/* generics.c */
#include &quot;generics.h&quot;

void *max(void *data[], int num, cmp_t cmp)
{
     int i;
     void *temp = data[0];
     for(i=1; i&lt;num; i++) {
	  if(cmp(temp, data[i])&lt;0)
	       temp = data[i];
     }
     return temp;
}
/* main.c */
#include &lt;stdio.h&gt;
#include &quot;generics.h&quot;

typedef struct {
     const char *name;
     int score;
} student_t;

int cmp_student(void *a, void *b)
{
     if(((student_t *)a)-&gt;score &gt; ((student_t *)b)-&gt;score)
	  return 1;
     else if(((student_t *)a)-&gt;score == ((student_t *)b)-&gt;score)
	  return 0;
     else
	  return -1;
}

int main(void)
{
     student_t list[4] = {{&quot;Tom&quot;, 68}, {&quot;Jerry&quot;, 72},
		       {&quot;Moby&quot;, 60}, {&quot;Kirby&quot;, 89}};
     student_t *plist[4] = {&amp;list[0], &amp;list[1], &amp;list[2], &amp;list[3]};
     student_t *pmax = max((void **)plist, 4, cmp_student);
     printf(&quot;%s gets the highest score %d\n&quot;, pmax-&gt;name, pmax-&gt;score);

     return 0;
}
</code></pre>
<p><code>max</code> 函数之所以能对一组任意类型的对象进行操作，关键在于传给 <code>max</code> 的是指向对象的指针所构成的数组，而不是对象本身所构成的数组，这样 <code>max</code> 不必关心对象到底是什么类型，只需转给比较函数 <code>cmp</code>，然后根据比较结果做相应操作即可，<code>cmp</code> 是调用者提供的回调函数，调用者当然知道对象是什么类型以及如何比较。</p>
<p>以上举例的回调函数是被同步调用的，调用者调用 <code>max</code> 函数，<code>max</code> 函数则调用 <code>cmp</code> 函数，相当于调用者间接调了自己提供的回调函数。在实际系统中，异步调用也是回调函数的一种典型用法，调用者首先将回调函数传给实现者，实现者记住这个函数，这称为<strong>注册</strong>一个回调函数，然后当某个事件发生时实现者再调用先前注册的函数，比如 <code>sigaction(2)</code> 注册一个信号处理函数，当信号产生时由系统调用该函数进行处理，再比如 <code>pthread_create(3)</code> 注册一个线程函数，当发生调度时系统切换到新注册的线程函数中运行，在 GUI 编程中异步回调函数更是有普遍的应用，例如为某个按钮注册一个回调函数，当用户点击按钮时调用它。</p>
<p>以下是一个代码框架。</p>
<pre><code class="language-c">/* registry.h */
#ifndef REGISTRY_H
#define REGISTRY_H

typedef void (*registry_t)(void);
extern void register_func(registry_t);

#endif
/* registry.c */
#include &lt;unistd.h&gt;
#include &quot;registry.h&quot;

static registry_t func;

void register_func(registry_t f)
{
     func = f;
}

static void on_some_event(void)
{
     ...
     func();
     ...
}
</code></pre>
<p>既然参数可以是函数指针，返回值同样也可以是函数指针，因此可以有 <code>func()();</code> 这样的调用。返回函数的函数在 C 语言中很少见，在一些函数式编程语言（例如 LISP）中则很常见，基本思想是把函数也当作一种数据来操作，输入、输出和参与运算，操作函数的函数称为高阶函数（High-order Function）。</p>
<h3 id="习题-2"><a class="header" href="#习题-2">习题</a></h3>
<ol>
<li><em>K&amp;R</em> 的 5.6 节有一个 <code>qsort</code> 函数的实现，可以对一组任意类型的对象做快速排序。请读者仿照那个例子，写一个插入排序的函数和一个折半查找的函数。</li>
</ol>
<h2 id="6-可变参数"><a class="header" href="#6-可变参数">6. 可变参数</a></h2>
<p>到目前为止我们只见过一个带有可变参数的函数 <code>printf</code>：</p>
<pre><code class="language-c">int printf(const char *format, ...);
</code></pre>
<p>以后还会见到更多这样的函数。现在我们实现一个简单的 <code>myprintf</code> 函数：</p>
<p id="e24-9">例 24.9. 用可变参数实现简单的 printf 函数</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

void myprintf(const char *format, ...)
{
     va_list ap;
     char c;

     va_start(ap, format);
     while (c = *format++) {
	  switch(c) {
	  case 'c': {
	       /* char is promoted to int when passed through '...' */
	       char ch = va_arg(ap, int);
	       putchar(ch);
	       break;
	  }
	  case 's': {
	       char *p = va_arg(ap, char *);
	       fputs(p, stdout);
	       break;
	  }
	  default:
	       putchar(c);
	  }
     }
     va_end(ap);
}

int main(void)
{
     myprintf(&quot;c\ts\n&quot;, '1', &quot;hello&quot;);
     return 0;
}
</code></pre>
<p>要处理可变参数，需要用 C 到标准库的 <code>va_list</code> 类型和 <code>va_start</code>、<code>va_arg</code>、<code>va_end</code> 宏，这些定义在 <code>stdarg.h</code> 头文件中。这些宏是如何取出可变参数的呢？我们首先对照反汇编分析在调用 <code>myprintf</code> 函数时这些参数的内存布局。</p>
<pre><code class="language-c">     myprintf(&quot;c\ts\n&quot;, '1', &quot;hello&quot;);
 80484c5:	c7 44 24 08 b0 85 04 	movl   $0x80485b0,0x8(%esp)
 80484cc:	08 
 80484cd:	c7 44 24 04 31 00 00 	movl   $0x31,0x4(%esp)
 80484d4:	00 
 80484d5:	c7 04 24 b6 85 04 08 	movl   $0x80485b6,(%esp)
 80484dc:	e8 43 ff ff ff       	call   8048424 &lt;myprintf&gt;
</code></pre>
<p id="c24-6">图 24.6. myprintf 函数的参数布局</p>
<p><img src="../images/interface.vaarg.png" alt="myprintf 函数的参数布局" /></p>
<p>这些参数是从右向左依次压栈的，所以第一个参数靠近栈顶，第三个参数靠近栈底。这些参数在内存中是连续存放的，每个参数都对齐到 4 字节边界。第一个和第三个参数都是指针类型，各占 4 个字节，虽然第二个参数只占一个字节，但为了使第三个参数对齐到 4 字节边界，所以第二个参数也占 4 个字节。现在给出一个 <code>stdarg.h</code> 的简单实现，这个实现出自 <em>Standard C Library</em>：</p>
<p id="e24-10">例 24.10. stdarg.h 的一种实现</p>
<pre><code class="language-c">/* stdarg.h standard header */
#ifndef _STDARG
#define _STDARG

/* type definitions */
typedef char *va_list;
/* macros */
#define va_arg(ap, T) \
	(* (T *)(((ap) += _Bnd(T, 3U)) - _Bnd(T, 3U)))
#define va_end(ap) (void)0
#define va_start(ap, A) \
	(void)((ap) = (char *)&amp;(A) + _Bnd(A, 3U))
#define _Bnd(X, bnd) (sizeof (X) + (bnd) &amp; ~(bnd))
#endif
</code></pre>
<p>这个头文件中的内部宏定义 <code>_Bnd(X, bnd)</code> 将类型或变量 <code>X</code> 的长度对齐到 <code>bnd+1</code> 字节的整数倍，例如 <code>_Bnd(char, 3U)</code> 的值是 4，<code>_Bnd(int, 3U)</code> 也是 4。</p>
<p>在 <code>myprintf</code> 中定义的 <code>va_list ap;</code> 其实是一个指针，<code>va_start(ap, format)</code> 使 <code>ap</code> 指向 <code>format</code> 参数的下一个参数，也就是指向上图中 <code>esp+4</code> 的位置。然后 <code>va_arg(ap, int)</code> 把第二个参数的值按 <code>int</code> 型取出来，同时使 <code>ap</code> 指向第三个参数，也就是指向上图中 <code>esp+8</code> 的位置。然后 <code>va_arg(ap, char *)</code> 把第三个参数的值按 <code>char *</code> 型取出来，同时使 <code>ap</code> 指向更高的地址。<code>va_end(ap)</code> 在我们的简单实现中不起任何作用，在有些实现中可能会把 <code>ap</code> 改写成无效值，C 标准要求在函数返回前调用 <code>va_end</code>。</p>
<p>如果把 <code>myprintf</code> 中的 <code>char ch = va_arg(ap, int);</code> 改成 <code>char ch = va_arg(ap, char);</code>，用我们这个 <code>stdarg.h</code> 的简单实现是没有问题的。但如果改用 <code>libc</code> 提供的 <code>stdarg.h</code>，在编译时会报错：</p>
<pre><code class="language-bash">$ gcc main.c
main.c: In function ‘myprintf’:
main.c:33: warning: ‘char’ is promoted to ‘int’ when passed through ‘...’
main.c:33: note: (so you should pass ‘int’ not ‘char’ to ‘va_arg’)
main.c:33: note: if this code is reached, the program will abort
$ ./a.out
Illegal instruction
</code></pre>
<p>因此要求 <code>char</code> 型的可变参数必须按 <code>int</code> 型来取，这是为了与 C 标准一致，我们在<a href="2-C-%E8%AF%AD%E8%A8%80%E6%9C%AC%E8%B4%A8/ch15-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3#_31-integer-promotion">第 15 章「数据类型详解」第 3.1 节「Integer Promotion」</a>讲过 Default Argument Promotion 规则，传递 <code>char</code> 型的可变参数时要提升为 <code>int</code> 型。</p>
<p>从 <code>myprintf</code> 的例子可以理解 <code>printf</code> 的实现原理，<code>printf</code> 函数根据第一个参数（格式化字符串）来确定后面有几个参数，分别是什么类型。保证参数的类型、个数与格式化字符串的描述相匹配是调用者的责任，实现者只管按格式化字符串的描述从栈上取数据，如果调用者传递的参数类型或个数不正确，实现者是没有办法避免错误的。</p>
<p>还有一种方法可以确定可变参数的个数，就是在参数列表的末尾传一个 Sentinel，例如 <code>NULL</code>。<code>execl(3)</code> 就采用这种方法确定参数的个数。下面实现一个 <code>printlist</code> 函数，可以打印若干个传入的字符串。</p>
<p id="e24-11">例 24.11. 根据 Sentinel 判断可变参数的个数</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

void printlist(int begin, ...)
{
     va_list ap;
     char *p;

     va_start(ap, begin);
     p = va_arg(ap, char *);

     while (p != NULL) {
	  fputs(p, stdout);
	  putchar('\n');
	  p = va_arg(ap, char*);
     }
     va_end(ap);
}

int main(void)
{
     printlist(0, &quot;hello&quot;, &quot;world&quot;, &quot;foo&quot;, &quot;bar&quot;, NULL);
     return 0;
}
</code></pre>
<p><code>printlist</code> 的第一个参数 <code>begin</code> 的值并没有用到，但是 C 语言规定至少要定义一个有名字的参数，因为 <code>va_start</code> 宏要用到参数列表中最后一个有名字的参数，从它的地址开始找可变参数的位置。实现者应该在文档中说明参数列表必须以 <code>NULL</code> 结尾，如果调用者不遵守这个约定，实现者是没有办法避免错误的。</p>
<h3 id="习题-3"><a class="header" href="#习题-3">习题</a></h3>
<ol>
<li>实现一个功能更完整的 <code>printf</code>，能够识别 <code>%</code>，能够处理 <code>%d</code>、<code>%f</code> 对应的整数参数。在实现中不许调用 <code>printf(3)</code> 这个 Man Page 中描述的任何函数。</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../2-C-语言本质/ch23-指针.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../2-C-语言本质/ch25-C-标准库.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../2-C-语言本质/ch23-指针.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../2-C-语言本质/ch25-C-标准库.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
