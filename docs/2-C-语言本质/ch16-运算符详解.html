<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>运算符详解 - Linux C 编程一站式学习</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">说明</a></li><li class="chapter-item expanded affix "><a href="../历史.html">历史</a></li><li class="chapter-item expanded affix "><a href="../前言.html">前言</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/TOC.html"><strong aria-hidden="true">1.</strong> C语言入门</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../1-C-语言入门/ch01-程序的基本概念.html"><strong aria-hidden="true">1.1.</strong> 程序的基本概念</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch02-常量、变量和表达式.html"><strong aria-hidden="true">1.2.</strong> 常量、变量和表达式</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch03-简单函数.html"><strong aria-hidden="true">1.3.</strong> 简单函数</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch04-分支语句.html"><strong aria-hidden="true">1.4.</strong> 分支语句</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch05-深入理解函数.html"><strong aria-hidden="true">1.5.</strong> 深入理解函数</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch06-循环语句.html"><strong aria-hidden="true">1.6.</strong> 循环语句</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch07-结构体.html"><strong aria-hidden="true">1.7.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch08-数组.html"><strong aria-hidden="true">1.8.</strong> 数组</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch09-编码风格.html"><strong aria-hidden="true">1.9.</strong> 编码风格</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch10-gdb.html"><strong aria-hidden="true">1.10.</strong> gdb</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch11-排序与查找.html"><strong aria-hidden="true">1.11.</strong> 排序与查找</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch12-栈与队列.html"><strong aria-hidden="true">1.12.</strong> 栈与队列</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch13-本阶段总结.html"><strong aria-hidden="true">1.13.</strong> 本阶段总结</a></li></ol></li><li class="chapter-item expanded "><a href="../2-C-语言本质/TOC.html"><strong aria-hidden="true">2.</strong> C-语言本质</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../2-C-语言本质/ch14-计算机中数的表示.html"><strong aria-hidden="true">2.1.</strong> 计算机中数的表示</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch15-数据类型详解.html"><strong aria-hidden="true">2.2.</strong> 数据类型详解</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch16-运算符详解.html" class="active"><strong aria-hidden="true">2.3.</strong> 运算符详解</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch17-计算机体系结构基础.html"><strong aria-hidden="true">2.4.</strong> 计算机体系结构基础</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch18-x86-汇编程序基础.html"><strong aria-hidden="true">2.5.</strong> x86-汇编程序基础</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch19-汇编与-C-之间的关系.html"><strong aria-hidden="true">2.6.</strong> 汇编与-C-之间的关系</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch20-链接详解.html"><strong aria-hidden="true">2.7.</strong> 链接详解</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch21-预处理.html"><strong aria-hidden="true">2.8.</strong> 预处理</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch22-Makefile-基础.html"><strong aria-hidden="true">2.9.</strong> Makefile-基础</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch23-指针.html"><strong aria-hidden="true">2.10.</strong> 指针</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch24-函数接口.html"><strong aria-hidden="true">2.11.</strong> 函数接口</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch25-C-标准库.html"><strong aria-hidden="true">2.12.</strong> C-标准库</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch26-链表、二叉树和哈希表.html"><strong aria-hidden="true">2.13.</strong> 链表、二叉树和哈希表</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch27-本阶段总结.html"><strong aria-hidden="true">2.14.</strong> 本阶段总结</a></li></ol></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/TOC.html"><strong aria-hidden="true">3.</strong> Linux-系统编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch28-文件与-IO.html"><strong aria-hidden="true">3.1.</strong> 文件与-IO</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch29-文件系统.html"><strong aria-hidden="true">3.2.</strong> 文件系统</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch30-进程.html"><strong aria-hidden="true">3.3.</strong> 进程</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch31-Shell-脚本.html"><strong aria-hidden="true">3.4.</strong> Shell-脚本</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch32-正则表达式.html"><strong aria-hidden="true">3.5.</strong> 正则表达式</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch33-信号.html"><strong aria-hidden="true">3.6.</strong> 信号</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch34-终端、作业控制与守护进程.html"><strong aria-hidden="true">3.7.</strong> 终端、作业控制与守护进程</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch35-线程.html"><strong aria-hidden="true">3.8.</strong> 线程</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch36-TCP-IP-协议基础.html"><strong aria-hidden="true">3.9.</strong> TCP-IP-协议基础</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch37-socket-编程.html"><strong aria-hidden="true">3.10.</strong> 编程</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linux C 编程一站式学习</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第-16-章-运算符详解"><a class="header" href="#第-16-章-运算符详解">第 16 章 运算符详解</a></h1>
<p>本章介绍很多前面没有讲过的运算符，重点是位运算，然后引出一个重要的概念 Sequence Point，在最后一节总结 C 语言各种运算符的优先级和结合性。</p>
<h2 id="1-位运算"><a class="header" href="#1-位运算">1. 位运算</a></h2>
<p>整数在计算机中用二进制的位来表示，C 语言提供一些运算符可以直接操作整数中的位，称为位运算，这些运算符的操作数都必须是整型的。在以后的学习中你会发现，有些信息利用整数中的某几个位来存储，要访问这些位，仅仅有对整数的操作是不够的，必须借助位运算，例如<a href="%E9%99%84%E5%BD%95-A-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81#_2-unicode-%E5%92%8C-utf-8">附录 A 第 2 节「Unicode 和 UTF-8」</a>介绍的 UTF-8 编码就是如此，学完本节之后你应该能自己写出 UTF-8 的编码和解码程序。本节首先介绍各种位运算符，然后介绍与位运算有关的编程技巧。</p>
<h3 id="11-按位与或异或取反运算"><a class="header" href="#11-按位与或异或取反运算">1.1. 按位与、或、异或、取反运算</a></h3>
<p>在<a href="1-C-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/ch04-%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5#_3-%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0">第 4 章「分支语句」第 3 节「布尔代数」</a>讲过逻辑与、或、非运算，并列出了真值表，对于整数中的位也可以做与、或、非运算，C 语言提供了按位与（Bitwise AND）运算符 <code>&amp;</code>、按位或（Bitwise OR）运算符 <code>|</code> 和按位取反（Bitwise NOT）运算符 <code>~</code>，此外还有按位异或（Bitwise XOR）运算符 <code>^</code>，我们在<a href="2-C-%E8%AF%AD%E8%A8%80%E6%9C%AC%E8%B4%A8/ch14-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA#_1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0">第 14 章「计算机中数的表示」第 1 节「为什么计算机用二进制计数」</a>讲过异或运算。下面用二进制的形式举几个例子。</p>
<p id="c16-1">图 16.1. 位运算</p>
<p><img src="../images/op.bitwise.png" alt="位运算" /></p>
<p>注意，<code>&amp;</code>、<code>|</code>、<code>^</code> 运算符都是要做 Usual  Arithmetic Conversion 的（其中有一步是 Integer Promotion），<code>~</code> 运算符也要做 Integer  Promotion，所以在 C 语言中其实并不存在 8 位整数的位运算，操作数在做位运算之前都至少被提升为 int 型了，上面用 8 位整数举例只是为了书写方便。比如：</p>
<pre><code class="language-c">unsigned char c = 0xfc;
unsigned int i = ~c;
</code></pre>
<p>计算过程是这样的：常量 <code>0xfc</code> 是 int 型的，赋给 <code>c</code> 要转成 unsigned char，值不变；<code>c</code> 的十六进制表示是 fc，计算 <code>~c</code> 时先提升为整型（<code>000000fc</code>）然后取反，最后结果是 <code>ffffff03</code>。注意，如果把 <code>~c</code> 看成是 8 位整数的取反，最后结果就得 3 了，这就错了。为了避免出错，一是尽量避免不同类型之间的赋值，二是每一步计算都要按上一章讲的类型转换规则仔细检查。</p>
<h3 id="12-移位运算"><a class="header" href="#12-移位运算">1.2. 移位运算</a></h3>
<p>移位运算符（Bitwise Shift）包括左移 <code>&lt;&lt;</code> 和右移 <code>&gt;&gt;</code>。左移将一个整数的各二进制位全部左移若干位，例如 <code>0xcfffffff3&lt;&lt;2</code> 得到 <code>0x3fffffcc</code>：</p>
<p id="c16-2">图 16.2. 左移运算</p>
<p><img src="../images/op.shiftleft.png" alt="左移运算" /></p>
<p>最高两位的 <code>11</code> 被移出去了，最低两位又补了两个 <code>0</code>，其它位依次左移两位。但要注意，移动的位数必须小于左操作数的总位数，比如上面的例子，左边是 unsigned int 型，如果左移的位数大于等于 32 位，则结果是 Undefined。移位运算符不同于 <code>+ - * / ==</code> 等运算符，两边操作数的类型不要求一致，但两边操作数都要做 Integer Promotion，整个表达式的类型和左操作数提升后的类型相同。</p>
<p>复习一下<a href="2-C-%E8%AF%AD%E8%A8%80%E6%9C%AC%E8%B4%A8/ch14-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA#_2-%E4%B8%8D%E5%90%8C%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8D%A2%E7%AE%97">第 14 章「计算机中数的表示」第 2 节「不同进制之间的换算」</a>讲过的知识可以得出结论，<strong>在一定的取值范围内，将一个整数左移 1 位相当于乘以 2</strong>。比如二进制 11（十进制 3）左移一位变成 110，就是 6，再左移一位变成 1100，就是 12。读者可以自己验证这条规律对有符号数和无符号数都成立，对负数也成立。当然，如果左移改变了最高位（符号位），那么结果肯定不是乘以 2 了，所以我加了个前提「在一定的取值范围内」。由于计算机做移位比做乘法快得多，编译器可以利用这一点做优化，比如看到源代码中有 <code>i * 8</code>，可以编译成移位指令而不是乘法指令。</p>
<p>当操作数是无符号数时，右移运算的规则和左移类似，例如 <code>0xcfffffff3&gt;&gt;2</code> 得到 <code>0x33fffffc</code>：</p>
<p id="c16-3">图 16.3. 右移运算</p>
<p><img src="../images/op.shiftright.png" alt="右移运算" /></p>
<p>最低两位的 <code>11</code> 被移出去了，最高两位又补了两个 <code>0</code>，其它位依次右移两位。和左移类似，移动的位数也必须小于左操作数的总位数，否则结果是 Undefined。在一定的取值范围内，将一个整数右移 1 位相当于除以 2，小数部分截掉。</p>
<p>当操作数是有符号数时，右移运算的规则比较复杂：</p>
<ul>
<li>如果是正数，那么高位移入 0</li>
<li>如果是负数，那么高位移入 1 还是 0 不一定，这是 Implementation-defined 的。对于 x86 平台的 <code>gcc</code> 编译器，最高位移入 1，也就是仍保持负数的符号位，这种处理方式对负数仍然保持了「右移 1 位相当于除以 2」的性质。</li>
</ul>
<p>综上所述，由于类型转换和移位等问题，用有符号数做位运算是很不方便的，所以，<strong>建议只对无符号数做位运算，以减少出错的可能</strong>。</p>
<h4 id="习题"><a class="header" href="#习题">习题</a></h4>
<ol>
<li>
<p>下面两行 <code>printf</code> 打印的结果有何不同？请读者比较分析一下。<code>%x</code> 转换说明的含义详见<a href="2-C-%E8%AF%AD%E8%A8%80%E6%9C%AC%E8%B4%A8/ch25-C-%E6%A0%87%E5%87%86%E5%BA%93#_29-%E6%A0%BC%E5%BC%8F%E5%8C%96-IO-%E5%87%BD%E6%95%B0">第 25 章「C 标准库」第 2.9 节「格式化 I/O 函数」</a>。</p>
<pre><code class="language-c">int i = 0xcffffff3;
printf(&quot;%x\n&quot;, 0xcffffff3&gt;&gt;2);
printf(&quot;%x\n&quot;, i&gt;&gt;2);
</code></pre>
</li>
</ol>
<h3 id="13-掩码"><a class="header" href="#13-掩码">1.3. 掩码</a></h3>
<p>如果要对一个整数中的某些位进行操作，怎样表示这些位在整数中的位置呢？可以用掩码（Mask）来表示。比如掩码 <code>0x0000ff00</code> 表示对一个 32 位整数的 8 ~ 15 位进行操作，举例如下。</p>
<ol>
<li>
<p>取出 8 ~ 15 位。</p>
<pre><code class="language-c">unsigned int a, b, mask = 0x0000ff00;
a = 0x12345678;
b = (a &amp; mask) &gt;&gt; 8; /* 0x00000056 */
</code></pre>
<p>这样也可以达到同样的效果：</p>
<pre><code class="language-c">b = (a &gt;&gt; 8) &amp; ~(~0U &lt;&lt; 8);
</code></pre>
</li>
<li>
<p>将 8 ~ 15 位清 0。</p>
<pre><code class="language-c">unsigned int a, b, mask = 0x0000ff00;
a = 0x12345678;
b = a &amp; ~mask; /* 0x12340078 */
</code></pre>
</li>
<li>
<p>将 8 ~ 15 位置 1。</p>
<pre><code class="language-c">unsigned int a, b, mask = 0x0000ff00;
a = 0x12345678;
b = a | mask; /* 0x1234ff78 */
</code></pre>
</li>
</ol>
<h4 id="习题-1"><a class="header" href="#习题-1">习题</a></h4>
<ol>
<li>统计一个无符号整数的二进制表示中 1 的个数，函数原型是 <code>int countbit(unsigned int x);</code>。</li>
<li>用位操作实现无符号整数的乘法运算，函数原型是 <code>unsigned int multiply(unsigned int x, unsigned int y);</code>。例如：(11011)<sub>2</sub>×(10010)<sub>2</sub>=((11011)<sub>2</sub>&lt;&lt;1)+((11011)<sub>2</sub>&lt;&lt;4)。</li>
<li>对一个 32 位无符号整数做循环右移，函数原型是 <code>unsigned int rotate_right(unsigned int x);</code>。所谓循环右移就是把低位移出去的部分再补到高位上去，例如 <code>rotate_right(0xdeadbeef, 16)</code> 的值应该是 <code>0xefdeadbe</code>。</li>
</ol>
<h3 id="14-异或运算的一些特性"><a class="header" href="#14-异或运算的一些特性">1.4. 异或运算的一些特性</a></h3>
<ol>
<li>
<p>一个数和自己做异或的结果是 0。如果需要一个常数 0，x86 平台的编译器可能会生成这样的指令：<code>xorl %eax, %eax</code>。不管 <code>eax</code> 寄存器里的值原来是多少，做异或运算都能得到 0，这条指令比同样效果的 <code>movl $0, %eax</code> 指令快，因为前者只需要在 CPU 内部计算，而后者需要访问内存，在<a href="2-C-%E8%AF%AD%E8%A8%80%E6%9C%AC%E8%B4%A8/ch17-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80#_5-memory-hierarchy">下一章第 5 节「Memory Hierarchy」</a>详细介绍。</p>
</li>
<li>
<p>从异或的真值表可以看出，不管是 0 还是 1，和 0 做异或保持原值不变，和 1 做异或得到原值的相反值。可以利用这个特性配合掩码实现某些位的翻转，例如：</p>
<pre><code class="language-c">unsigned int a, b, mask = 1U &lt;&lt; 6;
a = 0x12345678;
b = a ^ mask; /* flip the 6th bit */
</code></pre>
</li>
<li>
<p>如果 a1 ^ a2 ^ a3 ^ ... ^ an 的结果是 1，则表示 a1、a2、a3...an 之中 1 的个数为奇数个，否则为偶数个。这条性质可用于奇偶校验（Parity Check），比如在串口通信过程中，每个字节的数据都计算一个校验位，数据和校验位一起发送出去，这样接收方可以根据校验位粗略地判断接收到的数据是否有误。</p>
</li>
<li>
<p>x ^ x ^ y == y，因为 x ^ x == 0，0 ^ y == y。这个性质有什么用呢？我们来看这样一个问题：交换两个变量的值，不得借助额外的存储空间，所以就不能采用 <code>temp = a; a = b; b = temp;</code> 的办法了。利用位运算可以这样做交换：</p>
<pre><code class="language-c">a = a ^ b;
b = b ^ a;
a = a ^ b;
</code></pre>
</li>
</ol>
<p>分析一下这个过程。为了避免混淆，把 a 和 b 的初值分别记为 a<sub>0</sub> 和 b<sub>0</sub>。第一行，<code>a = a&lt;sub&gt;0&lt;/sub&gt; ^ b&lt;sub&gt;0&lt;/sub&gt;</code>；第二行，把 a 的新值代入，得到 <code>b = b&lt;sub&gt;0&lt;/sub&gt; ^ a&lt;sub&gt;0&lt;/sub&gt; ^ b&lt;sub&gt;0&lt;/sub&gt;</code>，等号右边的 b<sub>0</sub> 相当于上面公式中的 x，a<sub>0</sub> 相当于 y，所以结果为 a<sub>0</sub>；第三行，把 a 和 b 的新值代入，得到 <code>a = a&lt;sub&gt;0&lt;/sub&gt; ^ b&lt;sub&gt;0&lt;/sub&gt; ^ a&lt;sub&gt;0&lt;/sub&gt;</code>，结果为 b<sub>0</sub>。注意这个过程不能把同一个变量自己跟自己交换，而利用中间变量 <code>temp</code> 则可以交换。</p>
<h4 id="习题-2"><a class="header" href="#习题-2">习题</a></h4>
<ol>
<li>请在网上查找有关 RAID（Redundant Array of Independent Disks，独立磁盘冗余阵列）的资料，理解其实现原理，其实就是利用了本节的性质 3 和 4。</li>
<li>交换两个变量的值，不得借助额外的存储空间，除了本节讲的方法之外你还能想出什么方法？本节讲的方法不能把同一个变量自己跟自己交换，你的方法有没有什么局限性？</li>
</ol>
<h2 id="2-其它运算符"><a class="header" href="#2-其它运算符">2. 其它运算符</a></h2>
<h3 id="21-复合赋值运算符"><a class="header" href="#21-复合赋值运算符">2.1. 复合赋值运算符</a></h3>
<p>复合赋值运算符（Compound Assignment Operator）包括 <code>*=</code> <code>/=</code> <code>%=</code> <code>+=</code> <code>-=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>&amp;=</code> <code>^=</code> <code>|=</code>，一边做运算一边赋值。例如 <code>a += 1</code> 相当于 <code>a = a + 1</code>。但有一点细微的差别，前者对表达式 <code>a</code> 只求值一次，而后者求值两次，如果 <code>a</code> 是一个复杂的表达式，求值一次和求值两次的效率是不同的，例如 <code>a[i+j] += 1</code> 和 <code>a[i+j] = a[i+j] + 1</code>。那么仅仅是效率上的差别吗？对于没有 Side Effect 的表达式，求值一次和求值两次的结果是一样的，但对于有 Side Effect 的表达式则不一定，例如 <code>a[foo()] += 1</code> 和 <code>a[foo()] = a[foo()] + 1</code>，如果 <code>foo()</code> 函数调用有 Side Effect，比如会打印一条消息，那么前者只打印一次，而后者打印两次。</p>
<p>在<a href="1-C-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/ch06-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5#_3-for-%E8%AF%AD%E5%8F%A5">第 6 章第 3 节「for 语句」</a>讲自增、自减运算符时说 <code>++i</code> 相当于 <code>i = i + 1</code>，其实更准确地说应该是等价于 <code>i += 1</code>，表达式 <code>i</code> 只求值一次，而 <code>--i</code> 等价于 <code>i -= 1</code>。</p>
<h3 id="22-条件运算符"><a class="header" href="#22-条件运算符">2.2. 条件运算符</a></h3>
<p>条件运算符（Conditional Operator）是 C 语言中唯一一个三目运算符（Ternary Operator），带三个操作数，它的形式是 <code>表达式1 ? 表达式2 : 表达式3</code>，这个运算符所组成的整个表达式的值等于 <code>表达式2</code> 或 <code>表达式3</code> 的值，取决于 <code>表达式1</code> 的值是否为真，可以把它想像成这样的函数：</p>
<pre><code class="language-c">if (表达式1)
	return 表达式2;
else
	return 表达式3;
</code></pre>
<p><code>表达式1</code> 相当于 <code>if</code> 语句的控制表达式，因此它的值必须是标量类型，而 <code>表达式2</code>和 <code>表达式3</code> 相当于同一个函数在不同情况下的返回值，因此它们的类型要求一致，也要做 Usual Arithmetic Conversion。</p>
<p>下面举个例子，定义一个函数求两个参数中较大的一个。</p>
<pre><code class="language-c">int max(int a, int b)
{
	return (a &gt; b) ? a : b;
}
</code></pre>
<h3 id="23-逗号运算符"><a class="header" href="#23-逗号运算符">2.3. 逗号运算符</a></h3>
<p>逗号运算符（Comma Operator）也是一种双目运算符，它的形式是 <code>表达式1, 表达式2</code>，两个表达式不要求类型一致，左边的 <code>表达式1</code> 先求值，求完了直接把值丢掉，再求右边 <code>表达式2</code> 的值作为整个表达式的值。逗号运算符是左结合的，类似于 <code>+ - * /</code> 运算符，根据组合规则可以写出 <code>表达式1, 表达式2, 表达式3, ..., 表达式n</code> 这种形式，<code>表达式1, 表达式2</code> 可以看作一个子表达式，先求 <code>表达式1</code> 的值，然后求 <code>表达式2</code> 的值作为这个子表达式的值，然后这个值再和 <code>表达式3</code> 组成一个更大的表达式，求 <code>表达式3</code> 的值作为这个更大的表达式的值，依此类推，整个计算过程就是从左到右依次求值，最后一个表达式的值成为整个表达式的值。</p>
<p>注意，函数调用时各实参之间也是用逗号隔开，这种逗号是分隔符而不是逗号运算符。但可以这样使用逗号运算符：</p>
<pre><code class="language-c">f(a, (t=3, t+2), c)
</code></pre>
<p>传给函数 <code>f</code> 的参数有三个，其中第二个参数的值是表达式 <code>t+2</code> 的值。</p>
<h3 id="24-sizeof-运算符与-typedef-类型声明"><a class="header" href="#24-sizeof-运算符与-typedef-类型声明">2.4. sizeof 运算符与 typedef 类型声明</a></h3>
<p><code>sizeof</code> 是一个很特殊的运算符，它有两种形式：<code>sizeof 表达式</code> 和 <code>sizeof(类型名)</code>。这个运算符很特殊，<code>sizeof 表达式</code> 中的子表达式并不求值，而只是根据类型转换规则求得子表达式的类型，然后把这种类型所占的字节数作为整个表达式的值。有些人喜欢写成 <code>sizeof(表达式)</code> 的形式也可以，这里的括号和 <code>return(1);</code> 的括号一样，不起任何作用。但另外一种形式 <code>sizeof(类型名)</code> 的括号则是必须写的，整个表达式的值也是这种类型所占的字节数。</p>
<p>比如用 <code>sizeof</code> 运算符求一个数组的长度：</p>
<pre><code class="language-c">int a[12];
printf(&quot;%d\n&quot;, sizeof a/sizeof a[0]);
</code></pre>
<p>在上面这个例子中，由于 <code>sizeof 表达式</code> 中的子表达式不需要求值，所以不需要到运行时才计算，事实上在编译时就知道 <code>sizeof a</code> 的值是 48，<code>sizeof a[0]</code> 的值是 4，所以在编译时就已经把 <code>sizeof a/sizeof a[0]</code> 替换成常量 12 了，这是一个常量表达式。</p>
<p><code>sizeof</code> 运算符的结果是 <code>size_t</code> 类型的，这个类型定义在 <code>stddef.h</code> 头文件中，不过你的代码中只要不出现 <code>size_t</code> 这个类型名就不用包含这个头文件，比如像上面的例子就不用包含这个头文件。C 标准规定 <code>size_t</code> 是一种无符号整型，编译器可以用 <code>typedef</code> 做一个类型声明：</p>
<pre><code class="language-c">typedef unsigned long size_t;
</code></pre>
<p>那么 <code>size_t</code> 就代表 unsigned long 型。不同平台的编译器可能会根据自己平台的具体情况定义 <code>size_t</code> 所代表的类型，比如有的平台定义为 unsigned long 型，有的平台定义为 unsigned long long 型，C 标准规定 <code>size_t</code> 这个名字就是为了隐藏这些细节，使代码具有可移植性。所以注意不要把 <code>size_t</code> 类型和它所代表的真实类型混用，例如：</p>
<pre><code class="language-c">unsigned long x;
size_t y;
x = y;
</code></pre>
<p>如果在一种 ILP32 平台上定义 <code>size_t</code> 代表 unsigned long long 型，这段代码把 <code>y</code> 赋给 <code>x</code> 时就把高位截掉了，结果可能是错的。</p>
<p><code>typedef</code> 这个关键字用于给某种类型起个新名字，比如上面的 <code>typedef</code> 声明可以这么看：去掉 <code>typedef</code> 就成了一个变量声明 <code>unsigned long size_t;</code>，<code>size_t</code> 是一个变量名，类型是 unsigned long，那么加上 <code>typedef</code> 之后，<code>size_t</code> 就是一个类型名，就代表 unsigned long 类型。再举个例子：</p>
<pre><code class="language-c">typedef char array_t[10];
array_t a;
</code></pre>
<p>这相当于声明 <code>char a[10];</code>。类型名也遵循标识符的命名规则，并且通常加个 <code>_t</code> 后缀表示 Type。</p>
<h2 id="3-side-effect-与-sequence-point"><a class="header" href="#3-side-effect-与-sequence-point">3. Side Effect 与 Sequence Point</a></h2>
<p>如果你只想规规矩矩地写代码，那么基本用不着看这一节。本节的内容基本上是钻牛角尖儿的，除了 Short-circuit 比较实用，其它写法都应该避免使用。但没办法，有时候不是你想钻牛角尖儿，而是有人逼你去钻牛角尖儿。这是我们的学员在找工作笔试时碰到的问题：</p>
<pre><code class="language-c">int a=0;
a = (++a)+(++a)+(++a)+(++a);
</code></pre>
<p>据我了解，似乎很多公司都有出这种笔试题的恶趣味。答案应该是 Undefined，我甚至有些怀疑出题人是否真的知道答案。下面我来解释为什么是 Undefined。</p>
<p>我们知道，调用一个函数可能产生 Side  Effect，使用某些运算符（<code>++ -- =</code> 复合赋值）也会产生 Side Effect，如果一个表达式中隐含着多个 Side  Effect，究竟哪个先发生哪个后发生呢？C 标准规定代码中的某些点是 Sequence Point，当执行到一个 Sequence  Point 时，在此之前的 Side Effect 必须全部作用完毕，在此之后的 Side Effect 必须一个都没发生。至于两个 Sequence  Point 之间的多个 Side Effect 哪个先发生哪个后发生则没有规定，编译器可以任意选择各 Side  Effect 的作用顺序。下面详细解释各种 Sequence Point。</p>
<ol>
<li>
<p>调用一个函数时，在所有准备工作做完之后、函数调用开始之前是 Sequence Point。比如调用 <code>foo(f(), g())</code> 时，<code>foo</code>、<code>f()</code>、<code>g()</code> 这三个表达式哪个先求值哪个后求值是 Unspecified，但是必须都求值完了才能做最后的函数调用，所以 <code>f()</code>和<code>g()</code> 的 Side Effect 按什么顺序发生不一定，但必定在这些 Side Effect 全部作用完之后才开始调用 <code>foo</code> 函数。</p>
</li>
<li>
<p>条件运算符 <code>?:</code>、逗号运算符、逻辑与 <code>&amp;&amp;</code>、逻辑或 <code>||</code> 的第一个操作数求值之后是 Sequence Point。我们刚讲过条件运算符和逗号运算符，条件运算符要根据 <code>表达式1</code> 的值是否为真决定下一步求 <code>表达式2</code> 还是 <code>表达式3</code> 的值，如果决定求 <code>表达式2</code> 的值，<code>表达式3</code> 就不会被求值了，反之也一样，<code>,</code> 运算符也是这样，<code>表达式1</code> 求值结束才继续求 <code>表达式2</code> 的值。<br>
逻辑与和逻辑或早在<a href="1-C-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/ch04-%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5#_3-%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0">第 4 章「分支语句」第 3 节「布尔代数」</a>就讲了，但在初学阶段我一直回避它们的操作数求值顺序问题。这两个运算符和条件运算符类似，先求左操作数的值，然后根据这个值是否为真，右操作数可能被求值，也可能不被求值。比如<a href="1-C-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/ch08-%E6%95%B0%E7%BB%84#e8-5">第 8 章例 8.5 「剪刀石头布」</a>这个程序中的这几句：</p>
<pre><code class="language-c">ret = scanf(&quot;%d&quot;, &amp;man);
if (ret != 1 || man &lt; 0 || man &gt; 2) {
	printf(&quot;Invalid input! Please input 0, 1 or 2.\n&quot;);
	continue;
}
</code></pre>
<p>其实可以写得更简单（类似于 <em>K&amp;R</em> 的简洁风格）：</p>
<pre><code class="language-c">if (scanf(&quot;%d&quot;, &amp;man) != 1 || man &lt; 0 || man &gt; 2) {
	printf(&quot;Invalid input! Please input 0, 1 or 2.\n&quot;);
	continue;
}
</code></pre>
<p>这个控制表达式的求值顺序是：先求 <code>scanf(&quot;%d&quot;, &amp;man) = 1</code> 的值，如果 <code>scanf</code> 调用失败，则返回值不等于 1 成立，<code>||</code> 运算有一个操作数为真则整个表达式为真，这时直接执行下一句 <code>printf</code>，根本不会再去求 <code>man &lt; 0</code> 或 <code>man &gt; 2</code> 的值；如果 <code>scanf</code> 调用成功，则读入的数保存在变量 <code>man</code> 中，并且返回值等于 1，那么说它不等于 1 就不成立了，第一个 <code>||</code> 运算的左操作数为假，就会去求右操作数 <code>man &lt; 0</code> 的值作为整个表达式的值，这时变量 <code>man</code> 的值正是 <code>scanf</code> 读上来的值，我们判断它是否在 [0, 2] 之间，如果 <code>man &lt; 0</code> 不成立，则整个表达式 <code>scanf(&quot;%d&quot;, &amp;man) != 1 || man &lt; 0 </code> 的值为假，也就是第二个 <code>||</code> 运算的左操作数为假，所以最后求右操作数 <code>man &gt; 2</code> 的值作为整个表达式的值。
<code>&amp;&amp;</code> 运算与此类似，<code>a &amp;&amp; b</code> 的计算过程是：首先求表达式 <code>a</code> 的值，如果 <code>a</code> 的值是假则整个表达式的值是假，不会再去求 <code>b</code> 的值；如果 <code>a</code> 的值是真，则下一步求 <code>b</code> 的值作为整个表达式的值。所以，<code>a &amp;&amp; b</code> 相当于 「if a then b」，而 <code>a || b</code> 相当于「if not a then b」。这种特性称为 Short-circuit，很多人喜欢利用 Short-circuit 特性简化代码。</p>
</li>
<li>
<p>在一个完整的声明末尾是 Sequence Point，所谓完整的声明是指这个声明不是另外一个声明的一部分。比如声明 <code>int a[10], b[20];</code>，在 <code>a[10]</code> 末尾是 Sequence Point，在 <code>b[20]</code> 末尾也是。</p>
</li>
<li>
<p>在一个完整的表达式末尾是 Sequence Point，所谓完整的表达式是指这个表达式不是另外一个表达式的一部分。所以如果有 <code>f(); g();</code> 这样两条语句，<code>f()</code> 和 <code>g()</code> 是两个完整的表达式，<code>f()</code> 的 Side Effect 必定在 <code>g()</code> 之前发生。</p>
</li>
<li>
<p>在库函数即将返回时是 Sequence Point。这条规则似乎可以包含在上一条规则里面，因为函数返回时必然会结束掉一个完整的表达式。而事实上很多库函数是以宏定义的形式实现的（<a href="">第 21 章第 2.1 节「函数式宏定义」</a>），并不是真正的函数，所以才需要有这条规则。
还有两种 Sequence Point 和某些 C 标准库函数的执行过程相关，此处从略，有兴趣的读者可参考 <a href="">C99</a>的 Annex C。</p>
</li>
</ol>
<p>现在可以分析一下本节开头的例子了。<code>a = (++a)+(++a)+(++a)+(++a);</code> 的结果之所以是 Undefined，因为在这个表达式中有五个 Side Effect 都在改变 <code>a</code> 的值，这些 Side Effect 按什么顺序发生不一定，只知道在整个表达式求值结束时一定都发生了。比如现在求第二个 <code>++a</code> 的值，这时第一个、第三个、第四个 <code>++a</code> 的 Side Effect 发生了没有，<code>a</code> 的值被加过几次了，这些都不确定，所以第二个 <code>++a</code> 的值也不确定。这行代码用不同平台的不同编译器来编译结果是不同的，甚至在同一平台上用同一编译器的不同版本来编译也可能不同。</p>
<p>写表达式应遵循的原则一： <code>*</code> 在两个 Sequence Point 之间，同一个变量的值只允许被改变一次 <code>*</code>。仅有这一条原则还不够，例如 <code>a[i++] = i;</code> 的变量 <code>i</code> 只改变了一次，但结果仍是 Undefined，因为等号左边改 <code>i</code> 的值，等号右边读 <code>i</code> 的值，到底是先改还是先读？这个读写顺序是不确定的。但为什么 <code>i = i + 1;</code> 就没有歧义呢？虽然也是等号左边改 <code>i</code> 的值，等号右边读 <code>i</code> 的值，但你不读出 <code>i</code> 的值就没法计算 <code>i + 1</code>，那拿什么去改 <code>i</code> 的值呢？所以这个读写顺序是确定的。写表达式应遵循的原则二：<code>*</code> 如果在两个 Sequence Point 之间既要读一个变量的值又要改它的值，只有在读写顺序确定的情况下才可以这么写 <code>*</code>。</p>
<h2 id="4-运算符总结"><a class="header" href="#4-运算符总结">4. 运算符总结</a></h2>
<p>到此为止，除了和指针相关的运算符还没讲之外，其它运算符都讲过了，是时候做一个总结了。</p>
<p>运算符 <code>+  - * / % &gt; &lt; &gt;= &lt;= == != &amp; | ^</code> 以及各种复合赋值运算符要求两边的操作数类型一致，条件运算符 <code>?:</code> 要求后两个操作数类型一致，这些运算符在计算之前都需要做 Usual Arithmetic Conversion。</p>
<p>下面按优先级从高到低的顺序总结一下 C 语言的运算符，每一条所列的各运算符具有相同的优先级，对于同一优先级的多个运算符按什么顺序计算也有说明，双目运算符就简单地用「左结合」或「右结合」来说明了。和指针有关的运算符 <code>* &amp; -&gt;</code> 也在这里列出来了，到<a href="2-C-%E8%AF%AD%E8%A8%80%E6%9C%AC%E8%B4%A8/ch23-%E6%8C%87%E9%92%88">第 23 章「指针」</a>再详细解释。</p>
<ol>
<li>标识符、常量、字符串和用 <code>()</code> 括号套起来的表达式是组成表达式的最基本单元，在运算中做操作数，优先级最高。</li>
<li>后缀运算符，包括数组取下标 <code>[]</code>、函数调用 <code>()</code>、结构体取成员 <code>.</code>、指向结构体的指针取成员 <code>-&gt;</code>、后缀自增 <code>++</code>、后缀自减 <code>--</code>。如果一个操作数后面有多个后缀，按照离操作数从近到远的顺序（也就是从左到右）依次计算，比如 <code>a.name++</code>，先算 <code>a.name</code>，再 <code>++</code>，这里的 <code>.name</code> 应该看成 <code>a</code> 的一个后缀，而不是把 <code>.</code> 看成双目运算符。</li>
<li>单目运算符，包括前缀自增 <code>++</code>、前缀自减 <code>--</code>、<code>sizeof</code>、类型转换 <code>()</code>、取地址运算 <code>&amp;</code>、指针间接寻址 <code>*</code>、正号 <code>+</code>、负号 <code>-</code>、按位取反 <code>~</code>、逻辑非 <code>!</code>。如果一个操作数前面有多个前缀，按照离操作数从近到远的顺序（也就是从右到左）依次计算，比如 <code>!~a</code>，先算 <code>~a</code>，再求 <code>!</code>。</li>
<li>乘 <code>*</code>、除 <code>/</code>、模 <code>%</code> 运算符。这三个运算符是左结合的。</li>
<li>加 <code>+</code>、减 <code>-</code>运算符。左结合。</li>
<li>移位运算符 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code>。左结合。</li>
<li>关系运算符 <code>&lt; &gt; &lt;= &gt;=</code>。左结合。</li>
<li>相等性运算符 <code>==</code> 和 <code>!=</code>。左结合。</li>
<li>按位与 <code>&amp;</code>。左结合。</li>
<li>按位异或 <code>^</code>。左结合。</li>
<li>按位或 <code>|</code>。左结合。</li>
<li>逻辑与 <code>&amp;&amp;</code>。左结合。</li>
<li>逻辑或 <code>||</code>。左结合。</li>
<li>条件运算符 <code>:?</code>。在<a href="1-C-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/ch04-%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5?id=_2-ifelse-%E8%AF%AD%E5%8F%A5">第 4 章「分支语句」第 2 节「if/else语句」</a>讲过 Dangling-else 问题，条件运算符也有类似的问题。例如 <code>a ? b : c ? d : e</code> 是看成 <code>(a ? b : c) ? d : e</code> 还是 <code>a ? b : (c ? d : e)</code> 呢？C 语言规定是后者。</li>
<li>赋值=和各种复合赋值（<code>*=</code> <code>/=</code> <code>%=</code> <code>+=</code> <code>-=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>&amp;=</code> <code>^=</code> <code>|=</code>）。在双目运算符中只有赋值和复合赋值是右结合的。</li>
<li>逗号运算符。左结合。</li>
</ol>
<p><em>K&amp;R</em> 第 2 章也有这样一个列表，但是对于结合性解释得不够清楚。左结合和右结合这两个概念只对双目运算符有意义，对于前缀、后缀和三目运算符我单独做了说明。C 语言表达式的详细语法规则可以参考 <em>C99</em> 的 Annex A.2，其实语法规则并不是用优先级和结合性这两个概念来表述的，有一些细节用优先级和结合性是表达不了的，只有看 <em>C99</em> 才能了解完整的语法规则。</p>
<h3 id="习题-3"><a class="header" href="#习题-3">习题</a></h3>
<ol>
<li>
<p>以下代码得到的 <code>sum</code> 是 <code>0xffff</code>，对吗？</p>
<pre><code class="language-c">int i = 0;
unsigned int sum = 0;
for (; i &lt; 16; i++)
	sum = sum + 1U&lt;&lt;i;
</code></pre>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../2-C-语言本质/ch15-数据类型详解.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../2-C-语言本质/ch17-计算机体系结构基础.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../2-C-语言本质/ch15-数据类型详解.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../2-C-语言本质/ch17-计算机体系结构基础.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
