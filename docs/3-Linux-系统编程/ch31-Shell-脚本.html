<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Shell-脚本 - Linux C 编程一站式学习</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">说明</a></li><li class="chapter-item expanded affix "><a href="../历史.html">历史</a></li><li class="chapter-item expanded affix "><a href="../前言.html">前言</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/TOC.html"><strong aria-hidden="true">1.</strong> C语言入门</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../1-C-语言入门/ch01-程序的基本概念.html"><strong aria-hidden="true">1.1.</strong> 程序的基本概念</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch02-常量、变量和表达式.html"><strong aria-hidden="true">1.2.</strong> 常量、变量和表达式</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch03-简单函数.html"><strong aria-hidden="true">1.3.</strong> 简单函数</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch04-分支语句.html"><strong aria-hidden="true">1.4.</strong> 分支语句</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch05-深入理解函数.html"><strong aria-hidden="true">1.5.</strong> 深入理解函数</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch06-循环语句.html"><strong aria-hidden="true">1.6.</strong> 循环语句</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch07-结构体.html"><strong aria-hidden="true">1.7.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch08-数组.html"><strong aria-hidden="true">1.8.</strong> 数组</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch09-编码风格.html"><strong aria-hidden="true">1.9.</strong> 编码风格</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch10-gdb.html"><strong aria-hidden="true">1.10.</strong> gdb</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch11-排序与查找.html"><strong aria-hidden="true">1.11.</strong> 排序与查找</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch12-栈与队列.html"><strong aria-hidden="true">1.12.</strong> 栈与队列</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch13-本阶段总结.html"><strong aria-hidden="true">1.13.</strong> 本阶段总结</a></li></ol></li><li class="chapter-item expanded "><a href="../2-C-语言本质/TOC.html"><strong aria-hidden="true">2.</strong> C-语言本质</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../2-C-语言本质/ch14-计算机中数的表示.html"><strong aria-hidden="true">2.1.</strong> 计算机中数的表示</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch15-数据类型详解.html"><strong aria-hidden="true">2.2.</strong> 数据类型详解</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch16-运算符详解.html"><strong aria-hidden="true">2.3.</strong> 运算符详解</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch17-计算机体系结构基础.html"><strong aria-hidden="true">2.4.</strong> 计算机体系结构基础</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch18-x86-汇编程序基础.html"><strong aria-hidden="true">2.5.</strong> x86-汇编程序基础</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch19-汇编与-C-之间的关系.html"><strong aria-hidden="true">2.6.</strong> 汇编与-C-之间的关系</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch20-链接详解.html"><strong aria-hidden="true">2.7.</strong> 链接详解</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch21-预处理.html"><strong aria-hidden="true">2.8.</strong> 预处理</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch22-Makefile-基础.html"><strong aria-hidden="true">2.9.</strong> Makefile-基础</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch23-指针.html"><strong aria-hidden="true">2.10.</strong> 指针</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch24-函数接口.html"><strong aria-hidden="true">2.11.</strong> 函数接口</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch25-C-标准库.html"><strong aria-hidden="true">2.12.</strong> C-标准库</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch26-链表、二叉树和哈希表.html"><strong aria-hidden="true">2.13.</strong> 链表、二叉树和哈希表</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch27-本阶段总结.html"><strong aria-hidden="true">2.14.</strong> 本阶段总结</a></li></ol></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/TOC.html"><strong aria-hidden="true">3.</strong> Linux-系统编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch28-文件与-IO.html"><strong aria-hidden="true">3.1.</strong> 文件与-IO</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch29-文件系统.html"><strong aria-hidden="true">3.2.</strong> 文件系统</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch30-进程.html"><strong aria-hidden="true">3.3.</strong> 进程</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch31-Shell-脚本.html" class="active"><strong aria-hidden="true">3.4.</strong> Shell-脚本</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch32-正则表达式.html"><strong aria-hidden="true">3.5.</strong> 正则表达式</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch33-信号.html"><strong aria-hidden="true">3.6.</strong> 信号</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch34-终端、作业控制与守护进程.html"><strong aria-hidden="true">3.7.</strong> 终端、作业控制与守护进程</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch35-线程.html"><strong aria-hidden="true">3.8.</strong> 线程</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch36-TCP-IP-协议基础.html"><strong aria-hidden="true">3.9.</strong> TCP-IP-协议基础</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch37-socket-编程.html"><strong aria-hidden="true">3.10.</strong> 编程</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linux C 编程一站式学习</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第-31-章-shell-脚本"><a class="header" href="#第-31-章-shell-脚本">第 31 章 Shell 脚本</a></h1>
<h2 id="1-shell-的历史"><a class="header" href="#1-shell-的历史">1. Shell 的历史</a></h2>
<p>Shell 的作用是解释执行用户的命令，用户输入一条命令，Shell 就解释执行一条，这种方式称为交互式（Interactive），Shell 还有一种执行命令的方式称为批处理（Batch），用户事先写一个 Shell 脚本（Script），其中有很多条命令，让 Shell 一次把这些命令执行完，而不必一条一条地敲命令。Shell 脚本和编程语言很相似，也有变量和流程控制语句，但 Shell 脚本是解释执行的，不需要编译，Shell 程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到 Shell 提示符下执行。</p>
<p>由于历史原因，UNIX 系统上有很多种 Shell：</p>
<ol>
<li><code>sh</code>（Bourne Shell）：由 Steve Bourne 开发，各种 UNIX 系统都配有 <code>sh</code>。</li>
<li><code>csh</code>（C Shell）：由 Bill Joy 开发，随 BSD UNIX 发布，它的流程控制语句很像 C 语言，支持很多 Bourne Shell 所不支持的功能：作业控制，命令历史，命令行编辑。</li>
<li><code>ksh</code>（Korn Shell）：由 David Korn 开发，向后兼容 <code>sh</code> 的功能，并且添加了 <code>csh</code> 引入的新功能，是目前很多 UNIX 系统标准配置的 Shell，在这些系统上 <code>/bin/sh</code> 往往是指向 <code>/bin/ksh</code> 的符号链接。</li>
<li><code>tcsh</code>（TENEX C Shell）：是 <code>csh</code> 的增强版本，引入了命令补全等功能，在 FreeBSD、Mac OS X 等系统上替代了 <code>csh</code>。</li>
<li><code>bash</code>（Bourne Again Shell）：由 GNU 开发的 Shell，主要目标是与 POSIX 标准保持一致，同时兼顾对 <code>sh</code> 的兼容，<code>bash</code> 从 <code>csh</code> 和 <code>ksh</code> 借鉴了很多功能，是各种 Linux 发行版标准配置的 Shell，在 Linux 系统上 <code>/bin/sh</code> 往往是指向 <code>/bin/bash</code> 的符号链接<sup>[38]</sup>。虽然如此，<code>bash</code> 和 <code>sh</code> 还是有很多不同的，一方面，<code>bash</code> 扩展了一些命令和参数，另一方面，<code>bash</code> 并不完全和 <code>sh</code> 兼容，有些行为并不一致，所以 <code>bash</code> 需要模拟 <code>sh</code> 的行为：当我们通过 <code>sh</code> 这个程序名启动 <code>bash</code> 时，<code>bash</code> 可以假装自己是 <code>sh</code>，不认扩展的命令，并且行为与 <code>sh</code> 保持一致。</li>
</ol>
<blockquote>
<p><sup>[38]</sup> 最新的发行版有一些变化，例如 Ubuntu 7.10 的 <code>/bin/sh</code> 是指向 <code>/bin/dash</code> 的符号链接，<code>dash</code> 也是一种类似 <code>bash</code> 的 Shell。</p>
<pre><code class="language-bash">$ ls /bin/sh /bin/dash -l
-rwxr-xr-x 1 root root 79988 2008-03-12 19:22 /bin/dash
lrwxrwxrwx 1 root root     4 2008-07-04 05:58 /bin/sh -&gt; dash
</code></pre>
</blockquote>
<p>文件 <code>/etc/shells</code> 给出了系统中所有已知（不一定已安装）的 Shell，除了上面提到的 Shell 之外还有很多变种。</p>
<pre><code class="language-bash"># /etc/shells: valid login shells
/bin/csh
/bin/sh
/usr/bin/es
/usr/bin/ksh
/bin/ksh
/usr/bin/rc
/usr/bin/tcsh
/bin/tcsh
/usr/bin/esh
/bin/dash
/bin/bash
/bin/rbash
/usr/bin/screen
</code></pre>
<p>用户的默认 Shell 设置在 <code>/etc/passwd</code> 文件中，例如下面这行对用户 mia 的设置：</p>
<pre><code class="language-bash">mia:L2NOfqdlPrHwE:504:504:Mia Maya:/home/mia:/bin/bash
</code></pre>
<p>用户 mia 从字符终端登录或者打开图形终端窗口时就会自动执行 <code>/bin/bash</code>。如果要切换到其它 Shell，可以在命令行输入程序名，例如：</p>
<pre><code class="language-bash">~$ sh（在 bash 提示符下输入 sh 命令）
$（出现 sh 的提示符）
$（按 Ctrl-d 或者输入 exit 命令）
~$（回到 bash 提示符）
~$（再次按 Ctrl-d 或者输入 exit 命令会退出登录或者关闭图形终端窗口）
</code></pre>
<p>本章只介绍 <code>bash</code> 和 <code>sh</code> 的用法和相关语法，不介绍其它 Shell。所以下文提到 Shell 都是指 <code>bash</code> 或 <code>sh</code>。</p>
<h2 id="2-shell-如何执行命令"><a class="header" href="#2-shell-如何执行命令">2. Shell 如何执行命令</a></h2>
<h3 id="21-执行交互式命令"><a class="header" href="#21-执行交互式命令">2.1. 执行交互式命令</a></h3>
<p>用户在命令行输入命令后，一般情况下 Shell 会 <code>fork</code> 并 <code>exec</code> 该命令，但是 Shell 的内建命令例外，执行内建命令相当于调用Shell进程中的一个函数，并不创建新的进程。以前学过的 <code>cd</code>、<code>alias</code>、<code>umask</code>、<code>exit</code> 等命令即是内建命令，凡是用 <code>which</code> 命令查不到程序文件所在位置的命令都是内建命令，内建命令没有单独的 man 手册，要在 man 手册中查看内建命令，应该</p>
<pre><code class="language-bash">$ man bash-builtins
</code></pre>
<p>本节会介绍很多内建命令，如 <code>export</code>、<code>shift</code>、<code>if</code>、<code>eval</code>、<code>[</code>、<code>for</code>、<code>while</code> 等等。内建命令虽然不创建新的进程，但也会有 Exit Status，通常也用 0 表示成功非零表示失败，虽然内建命令不创建新的进程，但执行结束后也会有一个状态码，也可以用特殊变量 <code>$?</code> 读出。</p>
<h4 id="习题"><a class="header" href="#习题">习题</a></h4>
<ol>
<li>在完成<a href="3-Linux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/ch30-%E8%BF%9B%E7%A8%8B#_5-%E7%BB%83%E4%B9%A0%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84-shell">第 30 章第 5 节 「练习：实现简单的 Shell」</a>时也许有的读者已经试过了，在自己实现的 Shell 中不能执行 <code>cd</code> 命令，因为 <code>cd</code> 是一个内建命令，没有程序文件，不能用 <code>exec</code> 执行。现在请完善该程序，实现 <code>cd</code> 命令的功能，用 <code>chdir(2)</code> 函数可以改变进程的当前工作目录。</li>
<li>思考一下，为什么 <code>cd</code> 命令要实现成内建命令？可不可以实现一个独立的 <code>cd</code> 程序，例如 <code>/bin/cd</code>，就像 <code>/bin/ls</code> 一样？</li>
</ol>
<h3 id="22-执行脚本"><a class="header" href="#22-执行脚本">2.2. 执行脚本</a></h3>
<p>首先编写一个简单的脚本，保存为 <code>script.sh</code>：</p>
<p id="e31-1">例 31.1. 简单的 Shell 脚本</p>
<pre><code class="language-bash">#! /bin/sh

cd ..
ls
</code></pre>
<p>Shell 脚本中用 <code>#</code> 表示注释，相当于 C 语言的 <code>//</code> 注释。但如果 <code>#</code> 位于第一行开头，并且是 <code>#!</code>（称为 Shebang）则例外，它表示该脚本使用后面指定的解释器 <code>/bin/sh</code> 解释执行。如果把这个脚本文件加上可执行权限然后执行：</p>
<pre><code class="language-bash">$ chmod +x script.sh
$ ./script.sh
</code></pre>
<p>Shell 会 <code>fork</code> 一个子进程并调用 <code>exec</code> 执行 <code>./script.sh</code> 这个程序，<code>exec</code> 系统调用应该把子进程的代码段替换成 <code>./script.sh</code> 程序的代码段，并从它的 <code>_start</code> 开始执行。然而 <code>script.sh</code> 是个文本文件，根本没有代码段和 <code>_start</code> 函数，怎么办呢？其实 <code>exec</code> 还有另外一种机制，如果要执行的是一个文本文件，并且第一行用 Shebang 指定了解释器，则用解释器程序的代码段替换当前进程，并且从解释器的 <code>_start</code> 开始执行，而这个文本文件被当作命令行参数传给解释器。因此，执行上述脚本相当于执行程序</p>
<pre><code class="language-bash">$ /bin/sh ./script.sh
</code></pre>
<p>以这种方式执行不需要 <code>script.sh</code> 文件具有可执行权限。再举个例子，比如某个 <code>sed</code> 脚本的文件名是 <code>script</code>，它的开头是</p>
<pre><code class="language-bash">#! /bin/sed -f
</code></pre>
<p>执行 <code>./script</code> 相当于执行程序</p>
<pre><code class="language-bash">$ /bin/sed -f ./script.sh
</code></pre>
<p>以上介绍了两种执行 Shell 脚本的方法：</p>
<pre><code class="language-bash">$ ./script.sh
$ sh ./script.sh
</code></pre>
<p>这两种方法本质上是一样的，执行上述脚本的步骤为：</p>
<p id="c31-1">图 31.1. Shell脚本的执行过程</p>
<p><img src="../images/shellscript.shellexec.png" alt="Shell 脚本的执行过程" /></p>
<ol>
<li>交互 Shell（<code>bash</code>）<code>fork</code>/<code>exec</code> 一个子 Shell（<code>sh</code>）用于执行脚本，父进程 <code>bash</code> 等待子进程 <code>sh</code> 终止。</li>
<li><code>sh</code> 读取脚本中的 <code>cd ..</code> 命令，调用相应的函数执行内建命令，改变当前工作目录为上一级目录。</li>
<li><code>sh</code> 读取脚本中的 <code>ls</code> 命令，<code>fork</code>/<code>exec</code> 这个程序，列出当前工作目录下的文件，<code>sh</code> 等待 <code>ls</code> 终止。</li>
<li><code>ls</code> 终止后，<code>sh</code> 继续执行，读到脚本文件末尾，<code>sh</code> 终止。</li>
<li><code>sh</code> 终止后，<code>bash</code> 继续执行，打印提示符等待用户输入。</li>
</ol>
<p>如果将命令行下输入的命令用 <code>()</code> 括号括起来，那么也会 <code>fork</code> 出一个子 Shell 执行小括号中的命令，一行中可以输入由分号;隔开的多个命令，比如：</p>
<pre><code class="language-bash">$ (cd ..;ls -l)
</code></pre>
<p>和上面两种方法执行 Shell 脚本的效果是相同的，<code>cd ..</code> 命令改变的是子 Shell 的 <code>PWD</code>，而不会影响到交互式 Shell。然而命令</p>
<pre><code class="language-bash">$ cd ..;ls -l
</code></pre>
<p>则有不同的效果，<code>cd ..</code> 命令是直接在交互式 Shell 下执行的，改变交互式 Shell 的 <code>PWD</code>，然而这种方式相当于这样执行 Shell 脚本：</p>
<pre><code class="language-bash">$ source ./script.sh
</code></pre>
<p>或者</p>
<pre><code class="language-bash">$ . ./script.sh
</code></pre>
<p><code>source</code> 或者 <code>.</code> 命令是 Shell 的内建命令，这种方式也不会创建子 Shell，而是直接在交互式 Shell 下逐行执行脚本中的命令。</p>
<h4 id="习题-1"><a class="header" href="#习题-1">习题</a></h4>
<ol>
<li>解释如下命令的执行过程：</li>
</ol>
<pre><code class="language-bash">$ (exit 2)
$ echo $?
2
</code></pre>
<h2 id="3-shell-的基本语法"><a class="header" href="#3-shell-的基本语法">3. Shell 的基本语法</a></h2>
<h3 id="31-变量"><a class="header" href="#31-变量">3.1. 变量</a></h3>
<p>按照惯例，Shell 变量由全大写字母加下划线组成，有两种类型的 Shell 变量：</p>
<ul>
<li>
<p>环境变量：在<a href="3-Linux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/ch30-%E8%BF%9B%E7%A8%8B#_2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">第 30 章「进程」第 2 节「环境变量」</a>中讲过，环境变量可以从父进程传给子进程，因此 Shell 进程的环境变量可以从当前 Shell 进程传给 <code>fork</code> 出来的子进程。用 <code>printenv</code> 命令可以显示当前 Shell 进程的环境变量。</p>
</li>
<li>
<p>本地变量：只存在于当前 Shell 进程，用 <code>set</code> 命令可以显示当前 Shell 进程中定义的所有变量（包括本地变量和环境变量）和函数。</p>
</li>
</ul>
<p>环境变量是任何进程都有的概念，而本地变量是 Shell 特有的概念。在 Shell 中，环境变量和本地变量的定义和用法相似。在 Shell 中定义或赋值一个变量：</p>
<pre><code class="language-bash">$ VARNAME=value
</code></pre>
<p>注意等号两边都不能有空格，否则会被 Shell 解释成命令和命令行参数。</p>
<p>一个变量定义后仅存在于当前 Shell 进程，它是本地变量，用 <code>export</code> 命令可以把本地变量导出为环境变量，定义和导出环境变量通常可以一步完成：</p>
<pre><code class="language-bash">$ export VARNAME=value
</code></pre>
<p>也可以分两步完成：</p>
<pre><code class="language-bash">$ VARNAME=value
$ export VARNAME
</code></pre>
<p>用 <code>unset</code> 命令可以删除已定义的环境变量或本地变量。</p>
<pre><code class="language-bash">$ unset VARNAME
</code></pre>
<p>如果一个变量叫做 <code>VARNAME</code>，用 <code>${VARNAME}</code> 可以表示它的值，在不引起歧义的情况下也可以用 <code>$VARNAME</code> 表示它的值。通过以下例子比较这两种表示法的不同：</p>
<pre><code class="language-bash">$ echo $SHELL
$ echo $SHELLabc
$ echo $SHELL abc
$ echo ${SHELL}abc
</code></pre>
<p>注意，在定义变量时不用$，取变量值时要用 <code>$</code>。和 C 语言不同的是，Shell 变量不需要明确定义类型，事实上 Shell 变量的值都是字符串，比如我们定义 <code>VAR=45</code>，其实 <code>VAR</code> 的值是字符串 <code>45</code> 而非整数。Shell 变量不需要先定义后使用，如果对一个没有定义的变量取值，则值为空字符串。</p>
<h3 id="32-文件名代换globbing--"><a class="header" href="#32-文件名代换globbing--">3.2. 文件名代换（Globbing）：* ? []</a></h3>
<p>这些用于匹配的字符称为通配符（Wildcard），具体如下：</p>
<p id="">表 31.1. 通配符</p>
<table><thead><tr><th>*</th><th>匹配 0 个或多个任意字符</th></tr></thead><tbody>
<tr><td>?</td><td>匹配一个任意字符</td></tr>
<tr><td>[若干字符]</td><td>匹配方括号中任意一个字符的一次出现</td></tr>
</tbody></table>
<pre><code class="language-bash">$ ls /dev/ttyS*
$ ls ch0?.doc
$ ls ch0[0-2].doc
$ ls ch[012][0-9].doc
</code></pre>
<p>注意，Globbing 所匹配的文件名是由 Shell 展开的，也就是说在参数还没传给程序之前已经展开了，比如上述 <code>ls ch0[012].doc</code> 命令，如果当前目录下有 <code>ch00.doc</code> 和 <code>ch02.doc</code>，则传给 <code>ls</code> 命令的参数实际上是这两个文件名，而不是一个匹配字符串。</p>
<h3 id="33-命令代换-或-"><a class="header" href="#33-命令代换-或-">3.3. 命令代换：` 或 $()</a></h3>
<p>由反引号括起来的也是一条命令，Shell 先执行该命令，然后将输出结果立刻代换到当前命令行中。例如定义一个变量存放 <code>date</code> 命令的输出：</p>
<pre><code class="language-bash">$ DATE=`date`
$ echo $DATE
</code></pre>
<p>命令代换也可以用 <code>$()</code> 表示：</p>
<pre><code class="language-bash">$ DATE=$(date)
</code></pre>
<h3 id="34-算术代换"><a class="header" href="#34-算术代换">3.4. 算术代换：$(())</a></h3>
<p>用于算术计算，<code>$(())</code> 中的 Shell 变量取值将转换成整数，例如：</p>
<pre><code class="language-bash">$ VAR=45
$ echo $(($VAR+3))
</code></pre>
<p><code>$(())</code> 中只能用 <code>+-*/</code> 和 <code>()</code> 运算符，并且只能做整数运算。</p>
<h3 id="35-转义字符-"><a class="header" href="#35-转义字符-">3.5. 转义字符 \</a></h3>
<p>和 C 语言类似，\ 在 Shell 中被用作转义字符，用于去除紧跟其后的单个字符的特殊意义（回车除外），换句话说，紧跟其后的字符取字面值。例如：</p>
<pre><code class="language-bash">$ echo $SHELL
/bin/bash
$ echo \$SHELL
$SHELL
$ echo \\
\
</code></pre>
<p>比如创建一个文件名为「$ $」的文件可以这样：</p>
<pre><code class="language-bash">$ touch \$\ \$
</code></pre>
<p>还有一个字符虽然不具有特殊含义，但是要用它做文件名也很麻烦，就是 - 号。如果要创建一个文件名以 - 号开头的文件，这样是不行的：</p>
<pre><code class="language-bash">$ touch -hello
touch: invalid option -- h
Try `touch --help' for more information.
</code></pre>
<p>即使加上 <code>\</code> 转义也还是报错：</p>
<pre><code class="language-bash">$ touch \-hello
touch: invalid option -- h
Try `touch --help' for more information.
</code></pre>
<p>因为各种 UNIX 命令都把 - 号开头的命令行参数当作命令的选项，而不会当作文件名。如果非要处理以 - 号开头的文件名，可以有两种办法：</p>
<pre><code class="language-bash">$ touch ./-hello
</code></pre>
<p>或者</p>
<pre><code class="language-bash">$ touch -- -hello
</code></pre>
<p>\ 还有一种用法，在 \ 后敲回车表示续行，Shell 并不会立刻执行命令，而是把光标移到下一行，给出一个续行提示符 &gt;，等待用户继续输入，最后把所有的续行接到一起当作一个命令执行。例如：</p>
<pre><code class="language-bash">$ ls \
&gt; -l
（ls -l命令的输出）
</code></pre>
<h3 id="36-单引号"><a class="header" href="#36-单引号">3.6. 单引号</a></h3>
<p>和 C 语言不一样，Shell 脚本中的单引号和双引号一样都是字符串的界定符（双引号下一节介绍），而不是字符的界定符。单引号用于保持引号内所有字符的字面值，即使引号内的 \ 和回车也不例外，但是字符串中不能出现单引号。如果引号没有配对就输入回车，Shell 会给出续行提示符，要求用户把引号配上对。例如：</p>
<pre><code class="language-bash">$ echo '$SHELL'
$SHELL
$ echo 'ABC\（回车）
&gt; DE'（再按一次回车结束命令）
ABC\
DE
</code></pre>
<h3 id="37-双引号"><a class="header" href="#37-双引号">3.7. 双引号</a></h3>
<p>双引号用于保持引号内所有字符的字面值（回车也不例外），但以下情况除外：</p>
<ul>
<li>$ 加变量名可以取变量的值</li>
<li>反引号仍表示命令替换</li>
<li>\$ 表示 $ 的字面值</li>
<li>\` 表示 ` 的字面值</li>
<li>&quot; 表示 &quot; 的字面值</li>
<li>\\ 表示 \ 的字面值</li>
<li>除以上情况之外，在其它字符前面的 \ 无特殊含义，只表示字面值</li>
</ul>
<pre><code class="language-bash">$ echo &quot;$SHELL&quot;
/bin/bash
$ echo &quot;`date`&quot;
Sun Apr 20 11:22:06 CEST 2003
$ echo &quot;I'd say: \&quot;Go for it\&quot;&quot;
I'd say: &quot;Go for it&quot;
$ echo &quot;\&quot;（回车）
&gt;&quot;（再按一次回车结束命令）
&quot;

$ echo &quot;\\&quot;
\
</code></pre>
<h2 id="4-bash-启动脚本"><a class="header" href="#4-bash-启动脚本">4. bash 启动脚本</a></h2>
<p>启动脚本是 <code>bash</code> 启动时自动执行的脚本。用户可以把一些环境变量的设置和 <code>alias</code>、<code>umask</code> 设置放在启动脚本中，这样每次启动 Shell 时这些设置都自动生效。思考一下，<code>bash</code> 在执行启动脚本时是以 <code>fork</code> 子 Shell 方式执行的还是以 <code>source</code> 方式执行的？</p>
<p>启动 bash 的方法不同，执行启动脚本的步骤也不相同，具体可分为以下几种情况。</p>
<h3 id="41-作为交互登录-shell-启动或者使用---login-参数启动"><a class="header" href="#41-作为交互登录-shell-启动或者使用---login-参数启动">4.1. 作为交互登录 Shell 启动，或者使用 --login 参数启动</a></h3>
<p>交互 Shell 是指用户在提示符下输命令的 Shell 而非执行脚本的 Shell，登录 Shell 就是在输入用户名和密码登录后得到的 Shell，比如从字符终端登录或者用 <code>telnet</code>/<code>ssh</code> 从远程登录，但是从图形界面的窗口管理器登录之后会显示桌面而不会产生登录 Shell（也不会执行启动脚本），在图形界面下打开终端窗口得到的 Shell 也不是登录 Shell。</p>
<p>这样启动 <code>bash</code> 会自动执行以下脚本：</p>
<ol>
<li>首先执行 <code>/etc/profile</code>，系统中每个用户登录时都要执行这个脚本，如果系统管理员希望某个设置对所有用户都生效，可以写在这个脚本里</li>
<li>然后依次查找当前用户主目录的 <code>~/.bash_profile</code>、<code>~/.bash_login</code> 和 <code>~/.profile</code> 三个文件，找到第一个存在并且可读的文件来执行，如果希望某个设置只对当前用户生效，可以写在这个脚本里，由于这个脚本在 <code>/etc/profile</code> 之后执行，<code>/etc/profile</code> 设置的一些环境变量的值在这个脚本中可以修改，也就是说，当前用户的设置可以覆盖（Override）系统中全局的设置。<code>~/.profile</code> 这个启动脚本是 <code>sh</code> 规定的，<code>bash</code> 规定首先查找以 <code>~/.bash_</code> 开头的启动脚本，如果没有则执行 <code>~/.profile</code>，是为了和 <code>sh</code> 保持一致。</li>
<li>顺便一提，在退出登录时会执行 <code>~/.bash_logout</code> 脚本（如果它存在的话）。</li>
</ol>
<h3 id="42-以交互非登录-shell-启动"><a class="header" href="#42-以交互非登录-shell-启动">4.2. 以交互非登录 Shell 启动</a></h3>
<p>比如在图形界面下开一个终端窗口，或者在登录 Shell 提示符下再输入 <code>bash</code> 命令，就得到一个交互非登录的 Shell，这种 Shell 在启动时自动执行 <code>~/.bashrc</code> 脚本。</p>
<p>为了使登录 Shell 也能自动执行 <code>~/.bashrc</code>，通常在 <code>~/.bash_profile</code> 中调用 <code>~/.bashrc</code>：</p>
<pre><code class="language-bash">if [ -f ~/.bashrc ]; then
    . ~/.bashrc
fi
</code></pre>
<p>这几行的意思是如果 <code>~/.bashrc</code> 文件存在则 <code>source</code> 它。多数 Linux 发行版在创建帐户时会自动创建 <code>~/.bash_profile</code> 和 <code>~/.bashrc</code> 脚本，<code>~/.bash_profile</code> 中通常都有上面这几行。所以，如果要在启动脚本中做某些设置，使它在图形终端窗口和字符终端的 Shell 中都起作用，最好就是在 <code>~/.bashrc</code> 中设置。</p>
<p>下面做一个实验，在 <code>~/.bashrc</code> 文件末尾添加一行（如果这个文件不存在就创建它）：</p>
<pre><code class="language-bash">export PATH=$PATH:/home/akaedu
</code></pre>
<p>然后关掉终端窗口重新打开，或者从字符终端 <code>logout</code> 之后重新登录，现在主目录下的程序应该可以直接输程序名运行而不必输入路径了，例如：</p>
<pre><code class="language-bash">~$ a.out
</code></pre>
<p>就可以了，而不必</p>
<pre><code class="language-bash">~$ ./a.out
</code></pre>
<p>为什么登录 Shell 和非登录 Shell 的启动脚本要区分开呢？最初的设计是这样考虑的，如果从字符终端或者远程登录，那么登录 Shell 是该用户的所有其它进程的父进程，也是其它子 Shell 的父进程，所以环境变量在登录 Shell 的启动脚本里设置一次就可以自动带到其它非登录 Shell 里，而 Shell 的本地变量、函数、<code>alias</code> 等设置没有办法带到子 Shell 里，需要每次启动非登录 Shell 时设置一遍，所以就需要有非登录 Shell 的启动脚本，所以一般来说在 <code>~/.bash_profile</code> 里设置环境变量，在 <code>~/.bashrc</code> 里设置本地变量、函数、<code>alias</code> 等。如果你的 Linux 带有图形系统则不能这样设置，由于从图形界面的窗口管理器登录并不会产生登录 Shell，所以环境变量也应该在 <code>~/.bashrc</code> 里设置。 </p>
<h3 id="43-非交互启动"><a class="header" href="#43-非交互启动">4.3. 非交互启动</a></h3>
<p>为执行脚本而 <code>fork</code> 出来的子 Shell 是非交互 Shell，启动时执行的脚本文件由环境变量 <code>BASH_ENV</code> 定义，相当于自动执行以下命令：</p>
<pre><code class="language-bash">if [ -n &quot;$BASH_ENV&quot; ]; then . &quot;$BASH_ENV&quot;; fi
</code></pre>
<p>如果环境变量 <code>BASH_ENV</code> 的值不是空字符串，则把它的值当作启动脚本的文件名，<code>source</code> 这个脚本。</p>
<h3 id="44-以-sh-命令启动"><a class="header" href="#44-以-sh-命令启动">4.4. 以 sh 命令启动</a></h3>
<p>如果以 <code>sh</code> 命令启动 <code>bash</code>，<code>bash</code> 将模拟 <code>sh</code> 的行为，以 <code>~/.bash_</code> 开头的那些启动脚本就不认了。所以，如果作为交互登录 Shell 启动，或者使用 <code>--login</code> 参数启动，则依次执行以下脚本：</p>
<ol>
<li><code>/etc/profile</code></li>
<li><code>~/.profile</code></li>
</ol>
<p>如果作为交互 Shell 启动，相当于自动执行以下命令：</p>
<pre><code class="language-bash">if [ -n &quot;$ENV&quot; ]; then . &quot;$ENV&quot;; fi
</code></pre>
<p>如果作为非交互 Shell 启动，则不执行任何启动脚本。通常我们写的 Shell 脚本都以 <code>#! /bin/sh</code> 开头，都属于这种方式。</p>
<h2 id="5-shell-脚本语法"><a class="header" href="#5-shell-脚本语法">5. Shell 脚本语法</a></h2>
<h3 id="51-条件测试test-"><a class="header" href="#51-条件测试test-">5.1. 条件测试：test [</a></h3>
<p>命令 <code>test</code> 或 <code>[</code> 可以测试一个条件是否成立，如果测试结果为真，则该命令的 Exit Status 为 0，如果测试结果为假，则命令的 Exit Status 为 1（注意与 C 语言的逻辑表示正好相反）。例如测试两个数的大小关系：</p>
<pre><code class="language-bash">$ VAR=2
$ test $VAR -gt 1
$ echo $?
0
$ test $VAR -gt 3
$ echo $?
1
$ [ $VAR -gt 3 ]
$ echo $?
1
</code></pre>
<p><strong>虽然看起来很奇怪，但左方括号 <code>[</code> 确实是一个命令的名字，传给命令的各参数之间应该用空格隔开</strong>，比如，<code>$VAR</code>、<code>-gt</code>、<code>3</code>、<code>]</code> 是 <code>[</code> 命令的四个参数，它们之间必须用空格隔开。命令 <code>test</code> 或 <code>[</code> 的参数形式是相同的，只不过 <code>test</code> 命令不需要 <code>]</code> 参数。以 <code>[</code> 命令为例，常见的测试命令如下表所示：</p>
<p id="t31.2">表 31.2. 测试命令</p>
<table><thead><tr><th><code>[ -d DIR ]</code></th><th>如果 <code>DIR</code> 存在并且是一个目录则为真</th></tr></thead><tbody>
<tr><td><code>[ -f FILE ]</code></td><td>如果 <code>FILE</code> 存在且是一个普通文件则为真</td></tr>
<tr><td><code>[ -z STRING ]</code></td><td>如果 <code>STRING</code> 的长度为零则为真</td></tr>
<tr><td><code>[ -n STRING ]</code></td><td>如果 <code>STRING</code> 的长度非零则为真</td></tr>
<tr><td><code>[ STRING1 = STRING2 ]</code></td><td>如果两个字符串相同则为真</td></tr>
<tr><td><code>[ STRING1 != STRING2 ]</code></td><td>如果字符串不相同则为真</td></tr>
<tr><td><code>[ ARG1 OP ARG2 ]</code></td><td><code>ARG1</code> 和 <code>ARG2</code> 应该是整数或者取值为整数的变量，<code>OP</code> 是 <code>-eq</code>（等于）<code>-ne</code>（不等于）<code>-lt</code>（小于）<code>-le</code>（小于等于）<code>-gt</code>（大于）<code>-ge</code>（大于等于）之中的一个</td></tr>
</tbody></table>
<p>和 C 语言类似，测试条件之间还可以做与、或、非逻辑运算：</p>
<p id="t31.3">表 31.3. 带与、或、非的测试命令</p>
<table><thead><tr><th><code>[ ! EXPR ]</code></th><th><code>EXPR</code> 可以是上表中的任意一种测试条件，! 表示逻辑反</th></tr></thead><tbody>
<tr><td><code>[ EXPR1 -a EXPR2 ]</code></td><td><code>EXPR1</code> 和 <code>EXPR2</code> 可以是上表中的任意一种测试条件，<code>-a</code> 表示逻辑与</td></tr>
<tr><td><code>[ EXPR1 -o EXPR2 ]</code></td><td><code>EXPR1</code> 和 <code>EXPR2</code> 可以是上表中的任意一种测试条件，<code>-o</code> 表示逻辑或</td></tr>
</tbody></table>
<p>例如：</p>
<pre><code class="language-bash">$ VAR=abc
$ [ -d Desktop -a $VAR = 'abc' ]
$ echo $?
0
</code></pre>
<p>注意，如果上例中的 <code>$VAR</code> 变量事先没有定义，则被 Shell 展开为空字符串，会造成测试条件的语法错误（展开为 <code>[ -d Desktop -a  = 'abc' ]</code>），作为一种好的 Shell 编程习惯，应该总是把变量取值放在双引号之中（展开为 <code>[ -d Desktop -a &quot;&quot; = 'abc' ]</code>）：</p>
<pre><code class="language-bash">$ unset VAR
$ [ -d Desktop -a $VAR = 'abc' ]
bash: [: too many arguments
$ [ -d Desktop -a &quot;$VAR&quot; = 'abc' ]
$ echo $?
1
</code></pre>
<h3 id="52-ifthenelifelsefi"><a class="header" href="#52-ifthenelifelsefi">5.2. if/then/elif/else/fi</a></h3>
<p>和 C 语言类似，在 Shell 中用 <code>if</code>、<code>then</code>、<code>elif</code>、<code>else</code>、<code>fi</code> 这几条命令实现分支控制。这种流程控制语句本质上也是由若干条 Shell 命令组成的，例如先前讲过的</p>
<pre><code class="language-bash">if [ -f ~/.bashrc ]; then
    . ~/.bashrc
fi
</code></pre>
<p>其实是三条命令，<code>if [ -f ~/.bashrc ]</code> 是第一条，<code>then . ~/.bashrc</code> 是第二条，<code>fi</code> 是第三条。如果两条命令写在同一行则需要用 <code>;</code> 号隔开，一行只写一条命令就不需要写 <code>;</code> 号了，另外，<code>then</code> 后面有换行，但这条命令没写完，Shell 会自动续行，把下一行接在 <code>then</code> 后面当作一条命令处理。和 <code>[</code> 命令一样，要注意命令和各参数之间必须用空格隔开。<code>if</code> 命令的参数组成一条子命令，如果该子命令的 Exit Status 为 0（表示真），则执行 <code>then</code> 后面的子命令，如果 Exit Status 非 0（表示假），则执行 <code>elif</code>、<code>else</code> 或者 <code>fi</code> 后面的子命令。<code>if</code> 后面的子命令通常是测试命令，但也可以是其它命令。Shell 脚本没有 <code>{}</code>v括号，所以用 <code>fi</code> 表示 <code>if</code> 语句块的结束。见下例：</p>
<pre><code class="language-bash">#! /bin/sh

if [ -f /bin/bash ]
then echo &quot;/bin/bash is a file&quot;
else echo &quot;/bin/bash is NOT a file&quot;
fi
if :; then echo &quot;always true&quot;; fi
</code></pre>
<p><code>:</code> 是一个特殊的命令，称为空命令，该命令不做任何事，但 Exit Status 总是真。此外，也可以执行 <code>/bin/true</code> 或 <code>/bin/false</code> 得到真或假的 Exit Status。再看一个例子：</p>
<pre><code class="language-bash">#! /bin/sh

echo &quot;Is it morning? Please answer yes or no.&quot;
read YES_OR_NO
if [ &quot;$YES_OR_NO&quot; = &quot;yes&quot; ]; then
  echo &quot;Good morning!&quot;
elif [ &quot;$YES_OR_NO&quot; = &quot;no&quot; ]; then
  echo &quot;Good afternoon!&quot;
else
  echo &quot;Sorry, $YES_OR_NO not recognized. Enter yes or no.&quot;
  exit 1
fi
exit 0
</code></pre>
<p>上例中的 <code>read</code> 命令的作用是等待用户输入一行字符串，将该字符串存到一个 Shell 变量中。</p>
<p>此外，Shell 还提供了 <code>&amp;&amp;</code> 和 <code>||</code> 语法，和 C 语言类似，具有 Short-circuit 特性，很多 Shell 脚本喜欢写成这样：</p>
<pre><code class="language-bash">test &quot;$(whoami)&quot; != 'root' &amp;&amp; (echo you are using a non-privileged account; exit 1)
</code></pre>
<p><code>&amp;&amp;</code> 相当于 <code>if...then...</code>，而 <code>||</code> 相当于 <code>if not...then...</code>。<code>&amp;&amp;</code> 和 <code>||</code> 用于连接两个命令，而上面讲的 <code>-a</code> 和 <code>-o</code> 仅用于在测试表达式中连接两个测试条件，要注意它们的区别，例如，</p>
<pre><code class="language-bash">test &quot;$VAR&quot; -gt 1 -a &quot;$VAR&quot; -lt 3
</code></pre>
<p>和以下写法是等价的</p>
<pre><code class="language-bash">test &quot;$VAR&quot; -gt 1 &amp;&amp; test &quot;$VAR&quot; -lt 3
</code></pre>
<h3 id="53-caseesac"><a class="header" href="#53-caseesac">5.3. case/esac</a></h3>
<p><code>case</code> 命令可类比 C 语言的 <code>switch</code>/<code>case</code> 语句，<code>esac</code> 表示 <code>case</code> 语句块的结束。C 语言的 <code>case</code> 只能匹配整型或字符型常量表达式，而 Shell 脚本的 <code>case</code> 可以匹配字符串和 Wildcard，每个匹配分支可以有若干条命令，末尾必须以 <code>;;</code> 结束，执行时找到第一个匹配的分支并执行相应的命令，然后直接跳到 <code>esac</code> 之后，不需要像 C 语言一样用 <code>break</code> 跳出。</p>
<pre><code class="language-bash">#! /bin/sh

echo &quot;Is it morning? Please answer yes or no.&quot;
read YES_OR_NO
case &quot;$YES_OR_NO&quot; in
yes|y|Yes|YES)
  echo &quot;Good Morning!&quot;;;
[nN]*)
  echo &quot;Good Afternoon!&quot;;;
*)
  echo &quot;Sorry, $YES_OR_NO not recognized. Enter yes or no.&quot;
  exit 1;;
esac
exit 0
</code></pre>
<p>使用 <code>case</code> 语句的例子可以在系统服务的脚本目录 <code>/etc/init.d</code> 中找到。这个目录下的脚本大多具有这种形式（以 <code>/etc/apache2</code> 为例）：</p>
<pre><code class="language-bash">case $1 in
	start)
		...
	;;
	stop)
		...
	;;
	reload | force-reload)
		...
	;;
	restart)
	...
	*)
		log_success_msg &quot;Usage: /etc/init.d/apache2 {start|stop|restart|reload|force-reload|start-htcacheclean|stop-htcacheclean}&quot;
		exit 1
	;;
esac
</code></pre>
<p>启动 <code>apache2</code> 服务的命令是</p>
<pre><code class="language-bash">$ sudo /etc/init.d/apache2 start
</code></pre>
<p><code>$1</code> 是一个特殊变量，在执行脚本时自动取值为第一个命令行参数，也就是 <code>start</code>，所以进入 <code>start)</code> 分支执行相关的命令。同理，命令行参数指定为 <code>stop</code>、<code>reload</code> 或 <code>restart</code> 可以进入其它分支执行停止服务、重新加载配置文件或重新启动服务的相关命令。</p>
<h3 id="54-fordodone"><a class="header" href="#54-fordodone">5.4. for/do/done</a></h3>
<p>Shell 脚本的 <code>for</code> 循环结构和 C 语言很不一样，它类似于某些编程语言的 <code>foreach</code> 循环。例如：</p>
<pre><code class="language-bash">#! /bin/sh

for FRUIT in apple banana pear; do
  echo &quot;I like $FRUIT&quot;
done
</code></pre>
<p><code>FRUIT</code> 是一个循环变量，第一次循环 <code>$FRUIT</code> 的取值是 <code>apple</code>，第二次取值是 <code>banana</code>，第三次取值是 <code>pear</code>。再比如，要将当前目录下的 <code>chap0</code>、<code>chap1</code>、<code>chap2</code>等文件名改为 <code>chap0~</code>、<code>chap1~</code>、<code>chap2~</code> 等（按惯例，末尾有 <code>~</code> 字符的文件名表示临时文件），这个命令可以这样写：</p>
<pre><code class="language-bash">$ for FILENAME in chap?; do mv $FILENAME $FILENAME~; done
</code></pre>
<p>也可以这样写：</p>
<pre><code class="language-bash">$ for FILENAME in `ls chap?`; do mv $FILENAME $FILENAME~; done
</code></pre>
<h3 id="55-whiledodone"><a class="header" href="#55-whiledodone">5.5. while/do/done</a></h3>
<p><code>while</code> 的用法和 C 语言类似。比如一个验证密码的脚本：</p>
<pre><code class="language-bash">#! /bin/sh

echo &quot;Enter password:&quot;
read TRY
while [ &quot;$TRY&quot; != &quot;secret&quot; ]; do
  echo &quot;Sorry, try again&quot;
  read TRY
done
</code></pre>
<p>下面的例子通过算术运算控制循环的次数：</p>
<pre><code class="language-bash">#! /bin/sh

COUNTER=1
while [ &quot;$COUNTER&quot; -lt 10 ]; do
  echo &quot;Here we go again&quot;
  COUNTER=$(($COUNTER+1))
done
</code></pre>
<p>Shell 还有 <code>until</code> 循环，类似 C 语言的 <code>do...while</code> 循环。本章从略。</p>
<h4 id="习题-2"><a class="header" href="#习题-2">习题</a></h4>
<ol>
<li>把上面验证密码的程序修改一下，如果用户输错五次密码就报错退出。</li>
</ol>
<h3 id="56-位置参数和特殊变量"><a class="header" href="#56-位置参数和特殊变量">5.6. 位置参数和特殊变量</a></h3>
<p>有很多特殊变量是被Shell自动赋值的，我们已经遇到了 <code>$?</code> 和 <code>$1</code>，现在总结一下：</p>
<p id="t31-4">表 31.4. 常用的位置参数和特殊变量</p>
<table><thead><tr><th><code>$0</code></th><th>相当于 C 语言 <code>main</code> 函数的 <code>argv[0]</code></th></tr></thead><tbody>
<tr><td><code>$1</code>、<code>$2</code>...</td><td>这些称为位置参数（Positional Parameter），相当于 C 语言 <code>main</code> 函数的 <code>argv[1]</code>、<code>argv[2]</code>...</td></tr>
<tr><td><code>$#</code></td><td>相当于 C 语言 <code>main</code> 函数的 <code>argc - 1</code>，注意这里的 <code>#</code> 后面不表示注释</td></tr>
<tr><td><code>$@</code></td><td>表示参数列表 <code>&quot;$1&quot; &quot;$2&quot; ...</code>，例如可以用在 <code>for</code> 循环中的 <code>in</code> 后面。</td></tr>
<tr><td><code>$?</code></td><td>上一条命令的 Exit Status</td></tr>
<tr><td><code>$$</code></td><td>当前 Shell 的进程号</td></tr>
</tbody></table>
<p>位置参数可以用 <code>shift</code> 命令左移。比如 <code>shift 3</code> 表示原来的 <code>$4</code> 现在变成 <code>$1</code>，原来的 <code>$5</code> 现在变成 <code>$2</code> 等等，原来的 <code>$1</code>、<code>$2</code>、<code>$3</code> 丢弃，<code>$0</code> 不移动。不带参数的 <code>shift</code> 命令相当于 <code>shift 1</code>。例如：</p>
<pre><code class="language-bash">#! /bin/sh

echo &quot;The program $0 is now running&quot;
echo &quot;The first parameter is $1&quot;
echo &quot;The second parameter is $2&quot;
echo &quot;The parameter list is $@&quot;
shift
echo &quot;The first parameter is $1&quot;
echo &quot;The second parameter is $2&quot;
echo &quot;The parameter list is $@&quot;
</code></pre>
<h3 id="57-函数"><a class="header" href="#57-函数">5.7. 函数</a></h3>
<p>和 C 语言类似，Shell 中也有函数的概念，但是函数定义中没有返回值也没有参数列表。例如：</p>
<pre><code class="language-bash">#! /bin/sh

foo(){ echo &quot;Function foo is called&quot;;}
echo &quot;-=start=-&quot;
foo
echo &quot;-=end=-&quot;
</code></pre>
<p>注意函数体的左花括号 <code>{</code> 和后面的命令之间必须有空格或换行，如果将最后一条命令和右花括号 <code>}</code> 写在同一行，命令末尾必须有 <code>;</code> 号。</p>
<p>在定义 <code>foo()</code> 函数时并不执行函数体中的命令，就像定义变量一样，只是给 <code>foo</code> 这个名字一个定义，到后面调用 <code>foo</code> 函数的时候（注意 Shell 中的函数调用不写括号）才执行函数体中的命令。Shell 脚本中的函数必须先定义后调用，一般把函数定义都写在脚本的前面，把函数调用和其它命令写在脚本的最后（类似 C 语言中的 <code>main</code> 函数，这才是整个脚本实际开始执行命令的地方）。</p>
<p>Shell 函数没有参数列表并不表示不能传参数，事实上，函数就像是迷你脚本，调用函数时可以传任意个参数，在函数内同样是用 <code>$0</code>、<code>$1</code>、<code>$2</code> 等变量来提取参数，函数中的位置参数相当于函数的局部变量，改变这些变量并不会影响函数外面的 <code>$0</code>、<code>$1</code>、<code>$2</code> 等变量。函数中可以用 <code>return</code> 命令返回，如果 <code>return</code> 后面跟一个数字则表示函数的 Exit Status。</p>
<p>下面这个脚本可以一次创建多个目录，各目录名通过命令行参数传入，脚本逐个测试各目录是否存在，如果目录不存在，首先打印信息然后试着创建该目录。</p>
<pre><code class="language-bash">#! /bin/sh

is_directory()
{
  DIR_NAME=$1
  if [ ! -d $DIR_NAME ]; then
    return 1
  else
    return 0
  fi
}

for DIR in &quot;$@&quot;; do
  if is_directory &quot;$DIR&quot;
  then :
  else
    echo &quot;$DIR doesn't exist. Creating it now...&quot;
    mkdir $DIR &gt; /dev/null 2&gt;&amp;1
    if [ $? -ne 0 ]; then
      echo &quot;Cannot create directory $DIR&quot;
      exit 1
    fi
  fi
done
</code></pre>
<p>注意 <code>is_directory()</code> 返回 0 表示真返回 1 表示假。</p>
<h2 id="6-shell-脚本的调试方法"><a class="header" href="#6-shell-脚本的调试方法">6. Shell 脚本的调试方法</a></h2>
<p>Shell 提供了一些用于调试脚本的选项，如下所示：</p>
<ul>
<li>-n：读一遍脚本中的命令但不执行，用于检查脚本中的语法错误</li>
<li>-v： 一边执行脚本，一边将执行过的脚本命令打印到标准错误输出</li>
<li>-x：提供跟踪执行信息，将执行的每一条命令和结果依次打印出来</li>
</ul>
<p>使用这些选项有三种方法，一是在命令行提供参数</p>
<pre><code class="language-bash">$ sh -x ./script.sh
</code></pre>
<p>二是在脚本开头提供参数</p>
<pre><code class="language-bash">#! /bin/sh -x
</code></pre>
<p>第三种方法是在脚本中用 set 命令启用或禁用参数</p>
<pre><code class="language-bash">#! /bin/sh
if [ -z &quot;$1&quot; ]; then
  set -x
  echo &quot;ERROR: Insufficient Args.&quot;
  exit 1
  set +x
fi
</code></pre>
<p><code>set -x</code> 和 <code>set +x</code> 分别表示启用和禁用 <code>-x</code> 参数，这样可以只对脚本中的某一段进行跟踪调试。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../3-Linux-系统编程/ch30-进程.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../3-Linux-系统编程/ch32-正则表达式.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../3-Linux-系统编程/ch30-进程.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../3-Linux-系统编程/ch32-正则表达式.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
