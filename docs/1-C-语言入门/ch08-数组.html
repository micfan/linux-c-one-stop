<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>数组 - Linux C 编程一站式学习</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">说明</a></li><li class="chapter-item expanded affix "><a href="../历史.html">历史</a></li><li class="chapter-item expanded affix "><a href="../前言.html">前言</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/TOC.html"><strong aria-hidden="true">1.</strong> C语言入门</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../1-C-语言入门/ch01-程序的基本概念.html"><strong aria-hidden="true">1.1.</strong> 程序的基本概念</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch02-常量、变量和表达式.html"><strong aria-hidden="true">1.2.</strong> 常量、变量和表达式</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch03-简单函数.html"><strong aria-hidden="true">1.3.</strong> 简单函数</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch04-分支语句.html"><strong aria-hidden="true">1.4.</strong> 分支语句</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch05-深入理解函数.html"><strong aria-hidden="true">1.5.</strong> 深入理解函数</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch06-循环语句.html"><strong aria-hidden="true">1.6.</strong> 循环语句</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch07-结构体.html"><strong aria-hidden="true">1.7.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch08-数组.html" class="active"><strong aria-hidden="true">1.8.</strong> 数组</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch09-编码风格.html"><strong aria-hidden="true">1.9.</strong> 编码风格</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch10-gdb.html"><strong aria-hidden="true">1.10.</strong> gdb</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch11-排序与查找.html"><strong aria-hidden="true">1.11.</strong> 排序与查找</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch12-栈与队列.html"><strong aria-hidden="true">1.12.</strong> 栈与队列</a></li><li class="chapter-item expanded "><a href="../1-C-语言入门/ch13-本阶段总结.html"><strong aria-hidden="true">1.13.</strong> 本阶段总结</a></li></ol></li><li class="chapter-item expanded "><a href="../2-C-语言本质/TOC.html"><strong aria-hidden="true">2.</strong> C-语言本质</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../2-C-语言本质/ch14-计算机中数的表示.html"><strong aria-hidden="true">2.1.</strong> 计算机中数的表示</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch15-数据类型详解.html"><strong aria-hidden="true">2.2.</strong> 数据类型详解</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch16-运算符详解.html"><strong aria-hidden="true">2.3.</strong> 运算符详解</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch17-计算机体系结构基础.html"><strong aria-hidden="true">2.4.</strong> 计算机体系结构基础</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch18-x86-汇编程序基础.html"><strong aria-hidden="true">2.5.</strong> x86-汇编程序基础</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch19-汇编与-C-之间的关系.html"><strong aria-hidden="true">2.6.</strong> 汇编与-C-之间的关系</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch20-链接详解.html"><strong aria-hidden="true">2.7.</strong> 链接详解</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch21-预处理.html"><strong aria-hidden="true">2.8.</strong> 预处理</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch22-Makefile-基础.html"><strong aria-hidden="true">2.9.</strong> Makefile-基础</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch23-指针.html"><strong aria-hidden="true">2.10.</strong> 指针</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch24-函数接口.html"><strong aria-hidden="true">2.11.</strong> 函数接口</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch25-C-标准库.html"><strong aria-hidden="true">2.12.</strong> C-标准库</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch26-链表、二叉树和哈希表.html"><strong aria-hidden="true">2.13.</strong> 链表、二叉树和哈希表</a></li><li class="chapter-item expanded "><a href="../2-C-语言本质/ch27-本阶段总结.html"><strong aria-hidden="true">2.14.</strong> 本阶段总结</a></li></ol></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/TOC.html"><strong aria-hidden="true">3.</strong> Linux-系统编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch28-文件与-IO.html"><strong aria-hidden="true">3.1.</strong> 文件与-IO</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch29-文件系统.html"><strong aria-hidden="true">3.2.</strong> 文件系统</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch30-进程.html"><strong aria-hidden="true">3.3.</strong> 进程</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch31-Shell-脚本.html"><strong aria-hidden="true">3.4.</strong> Shell-脚本</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch32-正则表达式.html"><strong aria-hidden="true">3.5.</strong> 正则表达式</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch33-信号.html"><strong aria-hidden="true">3.6.</strong> 信号</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch34-终端、作业控制与守护进程.html"><strong aria-hidden="true">3.7.</strong> 终端、作业控制与守护进程</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch35-线程.html"><strong aria-hidden="true">3.8.</strong> 线程</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch36-TCP-IP-协议基础.html"><strong aria-hidden="true">3.9.</strong> TCP-IP-协议基础</a></li><li class="chapter-item expanded "><a href="../3-Linux-系统编程/ch37-socket-编程.html"><strong aria-hidden="true">3.10.</strong> 编程</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linux C 编程一站式学习</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第-8-章-数组"><a class="header" href="#第-8-章-数组">第 8 章 数组</a></h1>
<h2 id="1-数组的基本概念"><a class="header" href="#1-数组的基本概念">1. 数组的基本概念</a></h2>
<p>数组（Array）也是一种复合数据类型，它由一系列相同类型的元素（Element）组成。例如定义一个由 4 个 <code>int</code> 型元素组成的数组 <code>count</code>：</p>
<pre><code class="language-c">int count[4];
</code></pre>
<p>和结构体成员类似，数组 <code>count</code> 的 4 个元素的存储空间也是相邻的。结构体成员可以是基本数据类型，也可以是复合数据类型，数组中的元素也是如此。根据组合规则，我们可以定义一个由 4 个结构体元素组成的数组：</p>
<pre><code class="language-c">struct complex_struct {
	double x, y;
} a[4];
</code></pre>
<p>也可以定义一个包含数组成员的结构体：</p>
<pre><code class="language-c">struct {
	double x, y;
	int count[4];
} s;
</code></pre>
<p>数组类型的长度应该用一个整数常量表达式来指定<sup>[16]</sup>。数组中的元素通过下标（或者叫索引，Index）来访问。例如前面定义的由 4 个 <code>int</code> 型元素组成的数组 <code>count</code> 图示如下：</p>
<p id="c8-1">图 8.1. 数组 count</p>
<p><img src="../images/array.count.png" alt="数组 count" /></p>
<blockquote>
<p><sup>[16]</sup> C99 的新特性允许在数组长度表达式中使用变量，称为变长数组（VLA，Variable Length Array），VLA 只能定义为局部变量而不能是全局变量，与 VLA 有关的语法规则比较复杂，而且很多编译器不支持这种新特性，不建议使用。</p>
</blockquote>
<p>整个数组占了 4 个 <code>int</code> 型的存储单元，存储单元用小方框表示，里面的数字是存储在这个单元中的数据（假设都是 0），而框外面的数字是下标，这四个单元分别用 <code>count[0]</code>、<code>count[1]</code>、<code>count[2]</code>、<code>count[3]</code> 来访问。注意，在定义数组 <code>int count[4];</code> 时，方括号（Bracket）中的数字4表示数组的长度，而在访问数组时，方括号中的数字表示访问数组的第几个元素。和我们平常数数不同，数组元素是从「第 0 个」开始数的，大多数编程语言都是这么规定的，所以计算机术语中有 Zeroth 这个词。这样规定使得访问数组元素非常方便，比如 <code>count</code> 数组中的每个元素占 4 个字节，则 <code>count[i]</code> 表示从数组开头跳过 <code>4 * i</code> 个字节之后的那个存储单元。这种数组下标的表达式不仅可以表示存储单元中的值，也可以表示存储单元本身，也就是说可以做左值，因此以下语句都是正确的：</p>
<pre><code class="language-c">count[0] = 7;
count[1] = count[0] * 2;
++count[2];
</code></pre>
<p>到目前为止我们学习了五种<strong>后缀运算符</strong>：后缀 <code>++</code>、后缀 <code>--</code>、结构体取成员 <code>.</code>、数组取下标 <code>[]</code>、函数调用 <code>()</code>。还学习了五种<strong>单目运算符（或者叫前缀运算符）</strong>：前缀 <code>++</code>、前缀 <code>--</code>、正号 <code>+</code>、负号 <code>-</code>、逻辑非 <code>!</code>。在 C 语言中后缀运算符的优先级最高，单目运算符的优先级仅次于后缀运算符，比其它运算符的优先级都高，所以上面举例的 <code>++count[2]</code> 应该看作对 <code>count[2]</code> 做前缀 <code>++</code> 运算。</p>
<p>数组下标也可以是表达式，但表达式的值必须是整型的。例如：</p>
<pre><code class="language-c">int i = 10;
count[i] = count[i+1];
</code></pre>
<p>使用数组下标不能超出数组的长度范围，这一点在使用变量做数组下标时尤其要注意。C 编译器并不检查 <code>count[-1]</code> 或是 <code>count[100]</code> 这样的访问越界错误，编译时能顺利通过，所以属于运行时错误<sup>[17]</sup>。但有时候这种错误很隐蔽，发生访问越界时程序可能并不会立即崩溃，而执行到后面某个正确的语句时却有可能突然崩溃（在<a href="1-C-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/ch10-gdb#_4-%E6%AE%B5%E9%94%99%E8%AF%AF">第 10 章「gdb」第 4 节「段错误」</a>我们会看到这样的例子）。所以从一开始写代码时就要小心避免出问题，事后依靠调试来解决问题的成本是很高的。</p>
<blockquote>
<p><sup>[17]</sup> 你可能会想为什么编译器对这么明显的错误都视而不见？理由一，这种错误并不总是显而易见的，在<a href="2-C-%E8%AF%AD%E8%A8%80%E6%9C%AC%E8%B4%A8/ch23-%E6%8C%87%E9%92%88#_1-%E6%8C%87%E9%92%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">第 23 章「指针」第 1 节「指针的基本概念」</a>会讲到通过指针而不是数组名来访问数组的情况，指针指向数组中的什么位置只有运行时才知道，编译时无法检查是否越界，而运行时每次访问数组元素都检查越界会严重影响性能，所以干脆不检查了；理由二，C99 Rationale 指出 C 语言的设计精神是：相信每个 C 程序员都是高手，不要阻止程序员去干他们需要干的事，高手们使用 <code>count[-1]</code> 这种技巧其实并不少见，不应该当作错误。</p>
</blockquote>
<p>数组也可以像结构体一样初始化，未赋初值的元素也是用 <code>0</code> 来初始化，例如：</p>
<pre><code class="language-c">int count[4] = { 3, 2, };
</code></pre>
<p>则 <code>count[0]</code> 等于 3， <code>count[1]</code> 等于 2，后面两个元素等于 0。如果定义数组的同时初始化它，也可以不指定数组的长度，例如：</p>
<pre><code class="language-c">int count[] = { 3, 2, 1, };
</code></pre>
<p>编译器会根据 Initializer 有三个元素确定数组的长度为 3。利用 C99 的新特性也可以做 Memberwise Initialization：</p>
<pre><code class="language-c">int count[4] = { [2] = 3 };
</code></pre>
<p>下面举一个完整的例子：</p>
<p id="e8-1">例 8.1. 定义和访问数组</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
	int count[4] = { 3, 2, }, i;

	for (i = 0; i &lt; 4; i++)
		printf(&quot;count[%d]=%d\n&quot;, i, count[i]);
	return 0;
}
</code></pre>
<p>这个例子通过循环把数组中的每个元素依次访问一遍，在计算机术语中称为遍历（Traversal）。注意控制表达式 <code>i &lt; 4</code>，如果写成 <code>i &lt;= 4</code> 就错了，因为 <code>count[4]</code> 是访问越界。</p>
<p>数组和结构体虽然有很多相似之处，但也有一个显著的不同：数组不能相互赋值或初始化。例如这样是错的：</p>
<pre><code class="language-c">int a[5] = { 4, 3, 2, 1 };
int b[5] = a;
</code></pre>
<p>相互赋值也是错的：</p>
<pre><code class="language-c">a = b;
</code></pre>
<p>既然不能相互赋值，也就<strong>不能用数组类型作为函数的参数或返回值</strong>。如果写出这样的函数定义：</p>
<pre><code class="language-c">void foo(int a[5])
{
	...
}
</code></pre>
<p>然后这样调用：</p>
<pre><code class="language-c">int array[5] = {0};
foo(array);
</code></pre>
<p>编译器也不会报错，但这样写并不是传一个数组类型参数的意思。对于数组类型有一条特殊规则：<strong>数组类型做右值使用时，自动转换成指向数组首元素的指针</strong>。所以上面的函数调用其实是传一个指针类型的参数，而不是数组类型的参数。接下来的几章里有的函数需要访问数组，我们就把数组定义为全局变量给函数访问，等以后讲了指针再使用传参的办法。这也解释了为什么数组类型不能相互赋值或初始化，例如上面提到的 <code>a = b</code> 这个表达式，<code>a</code> 和 <code>b</code> 都是数组类型的变量，但是 <code>b</code> 做右值使用，自动转换成指针类型，而左边仍然是数组类型，所以编译器报的错是 <code>error: incompatible types in assignment</code>。</p>
<h3 id="习题"><a class="header" href="#习题">习题</a></h3>
<ol>
<li>编写一个程序，定义两个类型和长度都相同的数组，将其中一个数组的所有元素拷贝给另一个。既然数组不能直接赋值，想想应该怎么实现。</li>
</ol>
<h2 id="2-数组应用实例统计随机数"><a class="header" href="#2-数组应用实例统计随机数">2. 数组应用实例：统计随机数</a></h2>
<p>本节通过一个实例介绍使用数组的一些基本模式。问题是这样的：首先生成一列 0 ~ 9 的随机数保存在数组中，然后统计其中每个数字出现的次数并打印，检查这些数字的随机性如何。随机数在某些场合（例如游戏程序）是非常有用的，但是用计算机生成完全随机的数却不是那么容易。计算机执行每一条指令的结果都是确定的，没有一条指令产生的是随机数，调用 C 标准库得到的随机数其实是伪随机（Pseudorandom）数，是用数学公式算出来的确定的数，只不过这些数看起来很随机，并且从统计意义上也很接近均匀分布（Uniform Distribution）的随机数。</p>
<p>C 标准库中生成伪随机数的是 <code>rand</code> 函数，使用这个函数需要包含头文件 <code>stdlib.h</code>，它没有参数，返回值是一个介于 0 和 <code>RAND_MAX</code> 之间的接近均匀分布的整数。<code>RAND_MAX</code> 是该头文件中定义的一个常量，在不同的平台上有不同的取值，但可以肯定它是一个非常大的整数。通常我们用到的随机数是限定在某个范围之中的，例如 0 ~ 9，而不是 0 ~ <code>RAND_MAX</code>，我们可以用 <code>%</code> 运算符将 <code>rand</code> 函数的返回值处理一下：</p>
<pre><code class="language-c">int x = rand() % 10;
</code></pre>
<p>完整的程序如下：</p>
<p id="e8-2">例 8.2. 生成并打印随机数</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define N 20

int a[N];

void gen_random(int upper_bound)
{
	int i;
	for (i = 0; i &lt; N; i++)
		a[i] = rand() % upper_bound;
}

void print_random()
{
	int i;
	for (i = 0; i &lt; N; i++)
		printf(&quot;%d &quot;, a[i]);
	printf(&quot;\n&quot;);
}

int main(void)
{
	gen_random(10);
	print_random();
	return 0;
}
</code></pre>
<p>这里介绍一种新的语法：用 <code>#define</code> 定义一个常量。实际上编译器的工作分为两个阶段，先是预处理（Preprocess）阶段，然后才是编译阶段，用 <code>gcc</code> 的 <code>-E</code> 选项可以看到预处理之后、编译之前的程序，例如：</p>
<pre><code class="language-bash">$ gcc -E main.c
...（这里省略了很多行 stdio.h 和 stdlib.h 的代码）

int a[20];

void gen_random(int upper_bound)
{
 int i;
 for (i = 0; i &lt; 20; i++)
  a[i] = rand() % upper_bound;
}

void print_random()
{
 int i;
 for (i = 0; i &lt; 20; i++)
  printf(&quot;%d &quot;, a[i]);
 printf(&quot;\n&quot;);
}

int main(void)
{
 gen_random(10);
 print_random();
 return 0;
}
</code></pre>
<p>可见在这里预处理器做了两件事情，一是把头文件 <code>stdio.h</code> 和 <code>stdlib.h</code> 在代码中展开，二是把 <code>#define</code> 定义的标识符 <code>N</code> 替换成它的定义 20（在代码中做了三处替换，分别位于数组的定义中和两个函数中）。像 <code>#include</code> 和 <code>#define</code> 这种以 <code>#</code> 号开头的行称为预处理指示（Preprocessing Directive），我们将在<a href="2-C-%E8%AF%AD%E8%A8%80%E6%9C%AC%E8%B4%A8/ch21-%E9%A2%84%E5%A4%84%E7%90%86">第 21 章「预处理」</a>学习其它预处理指示。此外，用 <code>cpp main.c</code> 命令也可以达到同样的效果，只做预处理而不编译，<code>cpp</code> 表示 C preprocessor。</p>
<p>那么用 <code>#define</code> 定义的常量和<a href="1-C-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/ch07-%E7%BB%93%E6%9E%84%E4%BD%93#_3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A0%87%E5%BF%97">上一章「结构体」第 3 节「数据类型标志」</a>讲的枚举常量有什么区别呢？首先，<code>define</code> 不仅用于定义常量，也可以定义更复杂的语法结构，称为宏（Macro）定义。其次，<code>define</code> 定义是在预处理阶段处理的，而枚举是在编译阶段处理的。试试看把<a href="1-C-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/ch07-%E7%BB%93%E6%9E%84%E4%BD%93#%E4%B9%A0%E9%A2%98-1">上一章「结构体」第 3 节「数据类型标志」习题 2</a> 的程序改成下面这样是什么结果。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#define RECTANGULAR 1
#define POLAR 2

int main(void)
{
	int RECTANGULAR;
	printf(&quot;%d %d\n&quot;, RECTANGULAR, POLAR);
	return 0;
}
</code></pre>
<p>注意，虽然 <code>include</code> 和 <code>define</code> 在预处理指示中有特殊含义，但它们并不是 C 语言的关键字，换句话说，它们也可以用作标识符，例如声明 <code>int include;</code> 或者 <code>void define(int);</code>。在预处理阶段，如果一行以 <code>#</code> 号开头，后面跟 <code>include</code> 或 <code>define</code>，预处理器就认为这是一条预处理指示，除此之外出现在其它地方的 <code>include</code> 或 <code>define</code> 预处理器并不关心，只是当成普通标识符交给编译阶段去处理。</p>
<p>回到随机数这个程序继续讨论，一开始为了便于分析和调试，我们取小一点的数组长度，只生成 20 个随机数，这个程序的运行结果为：</p>
<pre><code class="language-bash">3 6 7 5 3 5 6 2 9 1 2 7 0 9 3 6 0 6 2 6
</code></pre>
<p>看起来很随机了。但随机性如何呢？分布得均匀吗？所谓均匀分布，应该每个数出现的概率是一样的。在上面的 20 个结果中，6 出现了 5 次，而 4 和 8 一次也没出现过。但这说明不了什么问题，毕竟我们的样本太少了，才 20 个数，如果样本足够多，比如说 100000 个数，统计一下其中每个数字出现的次数也许能说明问题。但总不能把 100000 个数都打印出来然后挨个去数吧？我们需要写一个函数统计每个数字出现的次数。完整的程序如下：</p>
<p id="e8-3">例 8.3. 统计随机数的分布</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define N 100000

int a[N];

void gen_random(int upper_bound)
{
	int i;
	for (i = 0; i &lt; N; i++)
		a[i] = rand() % upper_bound;
}

int howmany(int value)
{
	int count = 0, i;
	for (i = 0; i &lt; N; i++)
		if (a[i] == value)
			++count;
	return count;
}

int main(void)
{
	int i;

	gen_random(10);
	printf(&quot;value\thow many\n&quot;);
	for (i = 0; i &lt; 10; i++)
		printf(&quot;%d\t%d\n&quot;, i, howmany(i));

	return 0;
}
</code></pre>
<p>我们只要把 <code>#define N</code> 的值改为 100000，就相当于把整个程序中所有用到 <code>N</code> 的地方都改为 100000 了。如果我们不这么写，而是在定义数组时直接写成 <code>int a[20];</code>，在每个循环中也直接使用 20 这个值，这称为硬编码（Hard coding）。如果原来的代码是硬编码的，那么一旦需要把 20 改成 100000 就非常麻烦，你需要找遍整个代码，判断哪些 20 表示这个数组的长度就改为 100000，哪些 20 表示别的数量则不做改动，如果代码很长，这是很容易出错的。所以，<strong>写代码时应尽可能避免硬编码</strong>，这其实也是一个「提取公因式」的过程，和<a href="1-C-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/ch07-%E7%BB%93%E6%9E%84%E4%BD%93#_2-%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1">上一章「结构体」第 2 节「数据抽象」</a>讲的抽象具有相同的作用，就是避免一个地方的改动波及到大的范围。这个程序的运行结果如下：</p>
<pre><code class="language-bash">$ ./a.out
value    how many
0        10130
1        10072
2        9990
3        9842
4        10174
5        9930
6        10059
7        9954
8        9891
9        9958
</code></pre>
<p>各数字出现的次数都在 10000 次左右，可见是比较均匀的。</p>
<h3 id="习题-1"><a class="header" href="#习题-1">习题</a></h3>
<ol>
<li>用 <code>rand</code> 函数生成 [10, 20] 之间的随机整数，表达式应该怎么写？</li>
</ol>
<h2 id="3-数组应用实例直方图"><a class="header" href="#3-数组应用实例直方图">3. 数组应用实例：直方图</a></h2>
<p>继续上面的例子。我们统计一列 0 ~ 9 的随机数，打印每个数字出现的次数，像这样的统计结果称为直方图（Histogram）。有时候我们并不只是想打印，更想把统计结果保存下来以便做后续处理。我们可以把程序改成这样：</p>
<pre><code class="language-c">int main(void)
{
	int howmanyones = howmany(1);
	int howmanytwos = howmany(2);
	...
}
</code></pre>
<p>这显然太繁琐了。要是这样的随机数有 100 个呢？显然这里用数组最合适不过了：</p>
<pre><code class="language-c">int main(void)
{
	int i, histogram[10];

	gen_random(10);
	for (i = 0; i &lt; 10; i++)
		histogram[i] = howmany(i);
	...
}
</code></pre>
<p>有意思的是，这里的循环变量 <code>i</code> 有两个作用，一是作为参数传给 <code>howmany</code> 函数，统计数字 <code>i</code> 出现的次数，二是做 <code>histogram</code> 的下标，也就是「把数字 <code>i</code> 出现的次数保存在数组 <code>histogram</code> 的第 <code>i</code> 个位置」。</p>
<p>尽管上面的方法可以准确地得到统计结果，但是效率很低，这 100000 个随机数需要从头到尾检查十遍，每一遍检查只统计一种数字的出现次数。其实可以把 <code>histogram</code> 中的元素当作累加器来用，这些随机数只需要从头到尾检查一遍（Single Pass）就可以得出结果：</p>
<pre><code class="language-c">int main(void)
{
	int i, histogram[10] = {0};

	gen_random(10);
	for (i = 0; i &lt; N; i++)
		histogram[a[i]]++;
	...
}
</code></pre>
<p>首先把 <code>histogram</code> 的所有元素初始化为 0，注意使用局部变量的值之前一定要初始化，否则值是不确定的。接下来的代码很有意思，在每次循环中，<code>a[i]</code> 就是出现的随机数，而这个随机数同时也是 <code>histogram</code> 的下标，这个随机数每出现一次就把 <code>histogram</code> 中相应的元素加 1。</p>
<p>把上面的程序运行几遍，你就会发现每次产生的随机数都是一样的，不仅如此，在别的计算机上运行该程序产生的随机数很可能也是这样的。这正说明了这些数是伪随机数，是用一套确定的公式基于某个初值算出来的，只要初值相同，随后的整个数列就都相同。实际应用中不可能使用每次都一样的随机数，例如开发一个麻将游戏，每次运行这个游戏摸到的牌不应该是一样的。因此，C 标准库允许我们自己指定一个初值，然后在此基础上生成伪随机数，这个初值称为 Seed，可以用 <code>srand</code> 函数指定 Seed。通常我们通过别的途径得到一个不确定的数作为 Seed，例如调用 <code>time</code> 函数得到当前系统时间距 <code>1970 年 1 月 1 日 00:00:00</code> 的秒数<sup>[18]</sup>，然后传给 <code>srand</code>：</p>
<pre><code class="language-c">srand(time(NULL));
</code></pre>
<p>然后再调用 <code>rand</code>，得到的随机数就和刚才完全不同了。调用 <code>time</code> 函数需要包含头文件 <code>time.h</code>，这里的 <code>NULL</code> 表示空指针，到<a href="2-C-%E8%AF%AD%E8%A8%80%E6%9C%AC%E8%B4%A8/ch23-%E6%8C%87%E9%92%88#_1-%E6%8C%87%E9%92%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">第 23 章「指针」第 1 节「指针的基本概念」</a>再详细解释。</p>
<blockquote>
<p><sup>[18]</sup> 各种派生自 UNIX 的系统都把这个时刻称为 Epoch，因为 UNIX 系统最早发明于 1969 年。</p>
</blockquote>
<h3 id="习题-2"><a class="header" href="#习题-2">习题</a></h3>
<ol>
<li>
<p>补完本节直方图程序的 <code>main</code> 函数，以可视化的形式打印直方图。例如上一节统计 20 个随机数的结果是：</p>
<pre><code class="language-bash">0  1  2  3  4  5  6  7  8  9

*  *  *  *     *  *  *     *
*     *  *     *  *  *     *
      *  *        *
                  *
                  *
</code></pre>
</li>
<li>
<p>定义一个数组，编程打印它的全排列。比如定义：</p>
<pre><code class="language-c">#define N 3
int a[N] = { 1, 2, 3 };
</code></pre>
<p>则运行结果是：</p>
<pre><code class="language-bash">$ ./a.out
1 2 3 
1 3 2 
2 1 3 
2 3 1 
3 2 1 
3 1 2 
1 2 3
</code></pre>
<p>程序的主要思路是：</p>
 <ol>
 <li>把第 1 个数换到最前面来（本来就在最前面），准备打印 1xx，再对后两个数 2 和 3 做全排列。</li>
 <li>把第 2 个数换到最前面来，准备打印 2xx，再对后两个数 1 和 3 做全排列。</li>
 <li>把第 3 个数换到最前面来，准备打印 3xx，再对后两个数 1 和 2 做全排列。</li>
 </ol>
<p>可见这是一个递归的过程，把对整个序列做全排列的问题归结为对它的子序列做全排列的问题，注意我没有描述 Base Case 怎么处理，你需要自己想。你的程序要具有通用性，如果改变了 <code>N</code> 和数组 <code>a</code> 的定义（比如改成 4 个数的数组），其它代码不需要修改就可以做 4 个数的全排列（共 24 种排列）。</p>
<p>完成了上述要求之后再考虑第二个问题：如果再定义一个常量 <code>M</code> 表示从 <code>N</code> 个数中取几个数做排列（<code>N == M</code> 时表示全排列），原来的程序应该怎么改？</p>
<p>最后再考虑第三个问题：如果要求从 <code>N</code> 个数中取 <code>M</code> 个数做组合而不是做排列，就不能用原来的递归过程了，想想组合的递归过程应该怎么描述，编程实现它。</p>
</li>
</ol>
<h2 id="4-字符串"><a class="header" href="#4-字符串">4. 字符串</a></h2>
<p>之前我一直对字符串避而不谈，不做详细解释，现在已经具备了必要的基础知识，可以深入讨论一下字符串了。字符串可以看作一个数组，它的每个元素是字符型的，例如字符串 <code>&quot;Hello, world.\n&quot;</code> 图示如下：</p>
<p id="c8-2">图 8.2. 字符串</p>
<p><img src="../images/array.string.png" alt="字符串" /></p>
<p>注意每个字符**<abbr title="原无此字">串</abbr>**末尾都有一个字符 <code>'\0'</code> 做结束符，这里的 <code>\0</code> 是 ASCII 码的八进制表示，也就是 ASCII 码为 0 的 <code>Null</code> 字符，在 C 语言中这种字符串也称为「以零结尾的字符串」（Null-terminated String）。数组元素可以通过数组名加下标的方式访问，而字符串字面值也可以像数组名一样使用，可以加下标访问其中的字符：</p>
<pre><code class="language-c">char c = &quot;Hello, world.\n&quot;[0];
</code></pre>
<p>但是通过下标修改其中的字符却是不允许的：</p>
<pre><code class="language-c">&quot;Hello, world.\n&quot;[0] = 'A';
</code></pre>
<p>这行代码会产生编译错误，说字符串字面值是只读的，不允许修改。字符串字面值还有一点和数组名类似，做右值使用时自动转换成指向首元素的指针，在<a href="1-C-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/ch03-%E7%AE%80%E5%8D%95%E5%87%BD%E6%95%B0#_3-%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82">第 3 章「简单函数」第 3 节「形参和实参」</a>我们看到 <code>printf</code> 原型的第一个参数是指针类型，而 <code>printf(&quot;hello world&quot;)</code> 其实就是传一个指针参数给 <code>printf</code>。</p>
<p>前面讲过数组可以像结构体一样初始化，如果是字符数组，也可以用一个字符串字面值来初始化：</p>
<pre><code class="language-c">char str[10] = &quot;Hello&quot;;
</code></pre>
<p>相当于：</p>
<pre><code class="language-c">char str[10] = { 'H', 'e', 'l', 'l', 'o', '\0' };
</code></pre>
<p><code>str</code> 的后四个元素没有指定，自动初始化为 <code>'\0'</code>，即 <code>Null</code> 字符。注意，虽然字符串字面值 <code>&quot;Hello&quot;</code> 是只读的，但用它初始化的数组 <code>str</code> 却是可读可写的。数组 <code>str</code> 中保存了一串字符，以 <code>'\0'</code> 结尾，也可以叫字符串。在本书中只要是以 <code>Null</code> 字符结尾的一串字符都叫字符串，不管是像 <code>str</code> 这样的数组，还是像 <code>&quot;Hello&quot;</code> 这样的字符串字面值。</p>
<p>如果用于初始化的字符串字面值比数组还长，比如：</p>
<pre><code class="language-c">char str[10] = &quot;Hello, world.\n&quot;;
</code></pre>
<p>则数组 <code>str</code> 只包含字符串的前 10 个字符，不包含 <code>Null</code> 字符，这种情况编译器会给出警告。如果要用一个字符串字面值准确地初始化一个字符数组，最好的办法是不指定数组的长度，让编译器自己计算：</p>
<pre><code class="language-c">char str[] = &quot;Hello, world.\n&quot;;
</code></pre>
<p>字符串字面值的长度包括 <code>Null</code> 字符在内一共 15 个字符，编译器会确定数组 <code>str</code> 的长度为 15。</p>
<p>有一种情况需要特别注意，如果用于初始化的字符串字面值比数组刚好长出一个 <code>Null</code> 字符的长度，比如：</p>
<pre><code class="language-c">char str[14] = &quot;Hello, world.\n&quot;;
</code></pre>
<p>则数组 <code>str</code> 不包含 <code>Null</code> 字符，并且编译器不会给出警告，C99 Rationale 说这样规定是为程序员方便，以前的很多编译器都是这样实现的，不管它有理没理，C 标准既然这么规定了我们也没办法，只能自己小心了。</p>
<p>补充一点，<code>printf</code> 函数的格式化字符串中可以用 <code>%s</code> 表示字符串的占位符。在学字符数组以前，我们用 <code>%s</code> 没什么意义，因为</p>
<pre><code class="language-c">printf(&quot;string: %s\n&quot;, &quot;Hello&quot;);
</code></pre>
<p>还不如写成</p>
<pre><code class="language-c">printf(&quot;string: Hello\n&quot;);
</code></pre>
<p>但现在字符串可以保存在一个数组里面，用 <code>%s</code> 来打印就很有必要了：</p>
<pre><code class="language-c">printf(&quot;string: %s\n&quot;, str);
</code></pre>
<p><code>printf</code> 会从数组 <code>str</code> 的开头一直打印到 <code>Null</code> 字符为止，<code>Null</code> 字符本身是 Non-printable 字符，不打印。这其实是一个危险的信号：如果数组 <code>str</code> 中没有 <code>Null</code> 字符，那么 <code>printf</code> 函数就会访问数组越界，后果可能会很诡异：有时候打印出乱码，有时候看起来没错误，有时候引起程序崩溃。</p>
<h2 id="5-多维数组"><a class="header" href="#5-多维数组">5. 多维数组</a></h2>
<p>就像结构体可以嵌套一样，数组也可以嵌套，一个数组的元素可以是另外一个数组，这样就构成了多维数组（Multi-dimensional Array）。例如定义并初始化一个二维数组：</p>
<pre><code class="language-c">int a[3][2] = { 1, 2, 3, 4, 5 };
</code></pre>
<p>数组 <code>a</code> 有 3 个元素，<code>a[0]</code>、<code>a[1]</code>、<code>a[2]</code>。每个元素也是一个数组，例如 <code>a[0]</code> 是一个数组，它有两个元素 <code>a[0][0]</code>、<code>a[0][1]</code>，这两个元素的类型是 <code>int</code>，值分别是 1、2，同理，数组 <code>a[1]</code> 的两个元素是 3、4，数组 <code>a[2]</code>的两个元素是 5、0。如下图所示：</p>
<p id="c8-3">图 8.3. 多维数组</p>
<p><img src="../images/array.multidim.png" alt="多维数组" /></p>
<p>从概念模型上看，这个二维数组是三行两列的表格，元素的两个下标分别是行号和列号。从物理模型上看，这六个元素在存储器中仍然是连续存储的，就像一维数组一样，相当于把概念模型的表格一行一行接起来拼成一串，C 语言的这种存储方式称为 Row-major 方式，而有些编程语言（例如 FORTRAN）是把概念模型的表格一列一列接起来拼成一串存储的，称为 Column-major 方式。</p>
<p>多维数组也可以像嵌套结构体一样用嵌套 Initializer 初始化，例如上面的二维数组也可以这样初始化：</p>
<pre><code class="language-c">int a[][2] = { { 1, 2 },
		{ 3, 4 },
		{ 5, } };
</code></pre>
<p>注意，除了第一维的长度可以由编译器自动计算而不需要指定，其余各维都必须明确指定长度。利用 C99 的新特性也可以做 Memberwise Initialization，例如：</p>
<pre><code class="language-c">int a[3][2] = { [0][1] = 9, [2][1] = 8 };
</code></pre>
<p>结构体和数组嵌套的情况也可以做 Memberwise Initialization，例如：</p>
<pre><code class="language-c">struct complex_struct {
	double x, y;
} a[4] = { [0].x = 8.0 };

struct {
	double x, y;
	int count[4];
} s = { .count[2] = 9 };
</code></pre>
<p>如果是多维字符数组，也可以嵌套使用字符串字面值做 Initializer，例如：</p>
<p id="e8-4">例 8.4. 多维字符数组</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void print_day(int day)
{
	char days[8][10] = { &quot;&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;,
			     &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;,
			     &quot;Saturday&quot;, &quot;Sunday&quot; };

	if (day &lt; 1 || day &gt; 7)
		printf(&quot;Illegal day number!\n&quot;);
	printf(&quot;%s\n&quot;, days[day]);
}

int main(void)
{
	print_day(2);
	return 0;
}
</code></pre>
<p id="c8-4">图 8.4. 多维字符数组</p>
<p><img src="../images/array.multichar.png" alt="多维字符数组" /></p>
<p>这个程序中定义了一个多维字符数组 <code>char days[8][10];</code>，为了使 1 ~ 7 刚好映射到 <code>days[1]~days[7]</code>，我们把 <code>days[0]</code> 空出来不用，所以第一维的长度是 8，为了使最长的字符串 <code>&quot;Wednesday&quot;</code> 能够保存到一行，末尾还能多出一个 Null 字符的位置，所以第二维的长度是 10。</p>
<p>这个程序和<a href="104#e4-1">第 4 章「分支语句」例 4.1「switch 语句」</a>的功能其实是一样的，但是代码简洁多了。简洁的代码不仅可读性强，而且维护成本也低，像<a href="1-C-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/ch04-%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5#e4-1">第 4 章「分支语句」例 4.1「switch 语句」</a>那样一堆 <code>case</code>、<code>printf</code> 和 <code>break</code>，如果漏写一个 <code>break</code> 就要出 Bug。这个程序之所以简洁，是因为用数据代替了代码。具体来说，通过下标访问字符串组成的数组可以代替一堆 <code>case</code> 分支判断，这样就可以把每个 <code>case</code> 里重复的代码（<code>printf</code> 调用）提取出来，从而又一次达到了「提取公因式」的效果。这种方法称为<strong>数据驱动的编程</strong>（Data-driven Programming），写代码最重要的是选择正确的数据结构来组织信息，设计控制流程和算法尚在其次，只要数据结构选择得正确，其它代码自然而然就变得容易理解和维护了，就像这里的 <code>printf</code> 自然而然就被提取出来了。<em>人月神话</em>中说过：<em>Show  me your flowcharts and conceal your tables, and I shall continue to be  mystified. Show me your tables, and I won't usually need your  flowcharts; they'll be obvious.</em></p>
<p>最后，综合本章的知识，我们来写一个最简单的小游戏——剪刀石头布：</p>
<p id="e8-5">例 8.5. 剪刀石头布</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main(void)
{
	char gesture[3][10] = { &quot;scissor&quot;, &quot;stone&quot;, &quot;cloth&quot; };
	int man, computer, result, ret;

	srand(time(NULL));
	while (1) {
		computer = rand() % 3;
	  	printf(&quot;\nInput your gesture (0-scissor 1-stone 2-cloth):\n&quot;);
		ret = scanf(&quot;%d&quot;, &amp;man);
	  	if (ret != 1 || man &lt; 0 || man &gt; 2) {
			printf(&quot;Invalid input! Please input 0, 1 or 2.\n&quot;);
			continue;
		}
		printf(&quot;Your gesture: %s\tComputer's gesture: %s\n&quot;, 
			gesture[man], gesture[computer]);

		result = (man - computer + 4) % 3 - 1;
		if (result &gt; 0)
			printf(&quot;You win!\n&quot;);
		else if (result == 0)
			printf(&quot;Draw!\n&quot;);
		else
			printf(&quot;You lose!\n&quot;);
	}
	return 0;
}
</code></pre>
<p>0、1、2 三个整数分别是「剪刀、石头、布」在程序中的内部表示，用户也要求输入 0、1 或 2，然后和计算机随机生成的 0、1 或 2 比胜负。这个程序的主体是一个死循环，需要按 <code>Ctrl-C</code> 退出程序。以往我们写的程序都只有打印输出，在这个程序中我们第一次碰到处理用户输入的情况。我们简单介绍一下 <code>scanf</code> 函数的用法，到<a href="2-C-%E8%AF%AD%E8%A8%80%E6%9C%AC%E8%B4%A8/ch25-C-%E6%A0%87%E5%87%86%E5%BA%93#_29-%E6%A0%BC%E5%BC%8F%E5%8C%96-IO-%E5%87%BD%E6%95%B0">第 25 章「C 标准库」第 2.9 节「格式化 I/O 函数」</a>再详细解释。<code>scanf(&quot;%d&quot;, &amp;man)</code> 这个调用的功能是等待用户输入一个整数并回车，这个整数会被 <code>scanf</code> 函数保存在 <code>man</code> 这个整型变量里。如果用户输入合法（输入的确实是数字而不是别的字符），则 <code>scanf</code> 函数返回 1，表示成功读入一个数据。但即使用户输入的是整数，我们还需要进一步检查是不是在 0 ~ 2 的范围内，写程序时对用户输入要格外小心，用户有可能输入任何数据，他才不管游戏规则是什么。</p>
<p>和 <code>printf</code> 类似，<code>scanf</code> 也可以用 <code>%c</code>、<code>%f</code>、<code>%s</code> 等转换说明。如果在传给 <code>scanf</code> 的第一个参数中用 <code>%d</code>、<code>%f</code>或 <code>%c</code> 表示读入一个整数、浮点数或字符，则第二个参数的形式应该是 <code>&amp;</code> 运算符加相应类型的变量名，表示读进来的数保存到这个变量中，<code>&amp;</code> 运算符的作用是得到一个指针类型，到<a href="2-C-%E8%AF%AD%E8%A8%80%E6%9C%AC%E8%B4%A8/ch23-%E6%8C%87%E9%92%88#_1-%E6%8C%87%E9%92%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">第 23 章「指针」第 1 节「指针的基本概念」</a>再详细解释；如果在第一个参数中用 <code>%s</code> 读入一个字符串，则第二个参数应该是数组名，数组名前面不加 <code>&amp;</code>，因为数组类型做右值时自动转换成指针类型，在<a href="1-C-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/ch10-gdb#_2-%E6%96%AD%E7%82%B9">第 10 章「gdb」第 2 节「断点」</a>有 <code>scanf</code> 读入字符串的例子。</p>
<p>留给读者思考的问题是：<code>(man - computer + 4) % 3 - 1</code> 这个神奇的表达式是如何比较出 0、1、2 这三个数字在「剪刀石头布」意义上的大小的？</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../1-C-语言入门/ch07-结构体.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../1-C-语言入门/ch09-编码风格.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../1-C-语言入门/ch07-结构体.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../1-C-语言入门/ch09-编码风格.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
